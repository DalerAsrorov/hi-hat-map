(function () {
'use strict';

var _isPlaceholder = function _isPlaceholder(a) {
  return a != null &&
         typeof a === 'object' &&
         a['@@functional/placeholder'] === true;
};

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry1 = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
var isNil = _curry1(function isNil(x) { return x == null; });

// Initializing the map
// let mainMap = L.map('mapWrapper').setView([51.505, -0.09], 13);

// L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
//     maxZoom: 19,
//     attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
// }).addTo(mainMap);

var mapLayer = MQ.mapLayer();
var mainMap = void 0;

mainMap = L.map('mapWrapper', {
  layers: mapLayer,
  center: [40.731701, -73.993411],
  zoom: 12
});

L.control.layers({
  'Map': mapLayer,
  'Hybrid': MQ.hybridLayer(),
  'Satellite': MQ.satelliteLayer(),
  'Dark': MQ.darkLayer(),
  'Light': MQ.lightLayer()
}).addTo(mainMap);

var Map = mainMap;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/**
 *
 * Storage Base class
 *
 */

var Storage = function () {
   function Storage() {
      classCallCheck(this, Storage);
   }

   createClass(Storage, [{
      key: "getItem",
      value: function getItem(key) {}
   }, {
      key: "getRawItem",
      value: function getRawItem(key) {}
   }, {
      key: "setItem",
      value: function setItem(key, value) {}
   }, {
      key: "setRawItem",
      value: function setRawItem(key, value) {}
   }]);
   return Storage;
}();

var StorageSystem = function (_Storage) {
    inherits(StorageSystem, _Storage);

    function StorageSystem(localStorage) {
        classCallCheck(this, StorageSystem);

        var _this = possibleConstructorReturn(this, (StorageSystem.__proto__ || Object.getPrototypeOf(StorageSystem)).call(this));

        _this._localStorage = localStorage;
        return _this;
    }

    createClass(StorageSystem, [{
        key: 'getItem',
        value: function getItem(key) {
            return this._localStorage.getItem(key);
        }
    }, {
        key: 'getRawItem',
        value: function getRawItem(key) {
            return JSON.parse(this.getItem(key));
        }
    }, {
        key: 'setItem',
        value: function setItem(key, value) {
            this._localStorage.setItem(key, value);
        }
    }, {
        key: 'setRawItem',
        value: function setRawItem(key, value) {
            this.setItem(key, JSON.stringify(value));
        }
    }]);
    return StorageSystem;
}(Storage);

// UI Utils set
function slideToggleCp(targetID, map) {
    var heightSetterID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'arrowPointerWrapper';
    var cpDefaultHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "35%";

    var cpNavHeight = document.getElementById(heightSetterID).offsetHeight.toString();
    var cpWrapperHeight = document.getElementById(targetID).offsetHeight.toString();
    var slidingTime = 270;
    var defaultTop = "-15px";
    var $querySearchForm = $('#querySearchForm');
    var $target = $('#' + targetID);
    var $body = $('body');
    var $slideSwitchIcon = $('#slideSwitchIcon');

    var storageSystem = new StorageSystem(window.localStorage);

    //
    if (cpWrapperHeight === cpNavHeight) {
        $body.css({ "overflowY": "auto" });
        $target.animate({ height: cpDefaultHeight }, slidingTime);
        $querySearchForm.animate({
            top: "-15px"
        }, slidingTime);
        $slideSwitchIcon.addClass('fa-caret-down').removeClass('fa-caret-up');
        storageSystem.setItem("cpOpen", true);
    } else {
        $body.css({ "overflowY": "hidden" });
        $target.animate({ height: cpNavHeight }, slidingTime);
        $querySearchForm.animate({
            top: "-37px"
        }, slidingTime);
        map.invalidateSize();
        $slideSwitchIcon.addClass('fa-caret-up').removeClass('fa-caret-down');
        storageSystem.setItem("cpOpen", false);
    }
}

/**
*  Helper UI method that will keep the
*  control panel closed faster.
*/


/**
*   Based on the given target (div) and data (list of
*   available options), place a table (or list) of
*   widgets.
*/








function addClass(target, className) {
    $(target).addClass(className);
}



function removeClass(target, className) {
    $(target).removeClass(className);
}

// export function fadeOut(target, type, callbackHandler = function(){}) {
//     $(target).fadeOut(type, callbackHandler);
// }

function addEventListenerTo(target, type, fn) {
    document.getElementById(target).addEventListener(type, fn);
}

function removeElement(target) {
    $(target).remove();
}



function fadeOut(target, timer, callback) {
    $(target).fadeOut(timer, function () {
        // $('#initLoader').remove();
        // $('#mainWrapper').css({opacity: 0.0, visibility: "visible"}).animate({opacity: 1}, 1000);
        callback();
    });
}

function makeVisible(target, timer) {
    $(target).css({ opacity: 0.0, visibility: "visible" }).animate({ opacity: 1 }, timer);
}

function appendDropDownTo(target, dropdownName, dropdownID, actionsList) {
    // console.log("HERE", dropdownName, " HERE ", dropdownID, " HERE ", actionsList);
    var $targetRef = $(target).append('<div class="dropdown" id=' + dropdownID + '></div>');
    var $dropdown = $(target).find('#' + dropdownID);
    $dropdown.append('<button class=\'btn btn-secondary dropdown-toggle\' type=\'button\' data-toggle="dropdown">' + dropdownName + '</button>');
    var $dropdownRef = $dropdown.append('<div class=\'dropdown-menu\' </div>');
    var $listDiv = $dropdownRef.find('.dropdown-menu');

    actionsList.map(function (action, index) {
        $listDiv.append('\n            <a class =\'dropdown-item\' id=\'' + action.id + '\' href=\'#\'> ' + action.name + ' </a>\n        ');
    });
    $dropdown.append($listDiv);
    $(target).append($dropdown);
}

function appendRangeSlider(container, divClass, inputId, params) {
    var newRangeSlider = $('<div class=\'' + divClass + '\'>\n                            <input id=\'' + inputId + '\' type=\'text\'\n                             />\n                       </div>');
    var rangeInput = newRangeSlider.find('input');
    rangeInput.slider({
        ticks: params.ticks,
        ticks_labels: params.ticksLabels,
        min: params.min,
        max: params.max,
        step: params.step,
        value: params.value,
        tooltip: params.tooltip
    });

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Object.entries(params.eventHandlers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            // key == event and value == handler
            rangeInput.on(key, value);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    

    appendTo(container, newRangeSlider);
    rangeInput.slider('refresh');

    console.log('Range slider with divClass \'' + divClass + '\'\' is appended to \'' + container + '\'', appendTo('' + container, newRangeSlider));
}



function appendTo(container, element) {
    return !!$('' + container).append(element);
}

function appendDropDownToPanel(target, componentsClass) {
    console.log("componentsClass.list:", componentsClass.list);
    appendDropDownTo(target, componentsClass.name, componentsClass.id, componentsClass.list);
}

function onSubmit(target, callback) {
    $(target).submit(callback);
}

function getInputValue(target) {
    return $(target).val();
}

function getRequest(url) {
    return new Promise(function (res, rej) {
        $.get(url, function (data, status) {

            if (status === 'success') {
                console.log("Success");
                res(data);
            } else {
                rej("Couldn't get the file.");
            }
        });
    });
}

function postRequest(url, info) {
    return new Promise(function (res, rej) {
        $.post(url, info, function (data, status) {
            if (status === 'success') {
                res(data);
            } else {
                rej("Unsuccessful POST request.");
            }
        });
    });
}

function getGeoTrends(latLongString) {
    return window.location.origin + "/api/twitter/geotrends/" + latLongString;
}

function getTwitData() {
    return window.location.origin + "/api/twitter/twitdata";
}

function getSentimentTextAnalysis() {
    return window.location.origin + "/api/sentiment/evaluatestring";
}

function titleCase(str) {
    var escapeReg = function escapeReg(s) {
        return s.replace(/./g, function (c) {
            return '\\' + c;
        });
    };
    var wordPattern = new RegExp('[^' + escapeReg(' _-¡¿/') + ']+', 'g');
    var result = str.replace(wordPattern, capitalize);
    return result;
}





function capitalize(str) {
    if (str.length) {
        return str[0].toUpperCase() + str.slice(1).toLowerCase();
    } else {
        return '';
    }
}

/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry2 = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2
             : _curry1(function(_b) { return fn(a, _b); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })
             : fn(a, b);
    }
  };
};

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
var _isArray = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

var _isTransformer = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
var _dispatchable = function _dispatchable(methodNames, xf, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!_isArray(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

var _map = function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
};

var _xwrap = (function() {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function() {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function(acc) { return acc; };
  XWrap.prototype['@@transducer/step'] = function(acc, x) {
    return this.f(acc, x);
  };

  return function _xwrap(fn) { return new XWrap(fn); };
}());

var _arity = function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0: return function() { return fn.apply(this, arguments); };
    case 1: return function(a0) { return fn.apply(this, arguments); };
    case 2: return function(a0, a1) { return fn.apply(this, arguments); };
    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };
    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };
    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };
    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };
    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };
    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };
    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };
    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };
    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */
var bind = _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});

var _isString = function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
};

/**
 * Tests whether or not an object is similar to an array.
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @deprecated since v0.23.0
 * @example
 *
 *      R.isArrayLike([]); //=> true
 *      R.isArrayLike(true); //=> false
 *      R.isArrayLike({}); //=> false
 *      R.isArrayLike({length: 10}); //=> false
 *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
var isArrayLike = _curry1(function isArrayLike(x) {
  if (_isArray(x)) { return true; }
  if (!x) { return false; }
  if (typeof x !== 'object') { return false; }
  if (_isString(x)) { return false; }
  if (x.nodeType === 1) { return !!x.length; }
  if (x.length === 0) { return true; }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});

var _reduce = (function() {
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj) {
    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';
  return function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list);
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    throw new TypeError('reduce: list must be array or iterable');
  };
}());

var _xfBase = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

var _xmap = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });
}());

/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curryN = function _curryN(length, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length &&
          (!_isPlaceholder(received[combinedIdx]) ||
           argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined)
                     : _arity(left, _curryN(length, combined, fn));
  };
};

/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curryN = _curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});

var _has = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

var _isArguments = (function() {
  var toString = Object.prototype.toString;
  return toString.call(arguments) === '[object Arguments]' ?
    function _isArguments(x) { return toString.call(x) === '[object Arguments]'; } :
    function _isArguments(x) { return _has('callee', x); };
}());

/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
var keys = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = (function() {
    'use strict';
    return arguments.propertyIsEnumerable('length');
  }());

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' && !hasArgsEnumBug ?
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */
var map = _curry2(_dispatchable(['map'], _xmap, function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return curryN(functor.length, function() {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return _reduce(function(acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, keys(functor));
    default:
      return _map(fn, functor);
  }
}));

var _pipe = function _pipe(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
};

/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry3 = function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3
             : _curry2(function(_b, _c) { return fn(a, _b, _c); });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3
             : _isPlaceholder(a) ? _curry2(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder(b) ? _curry2(function(_b, _c) { return fn(a, _b, _c); })
             : _curry1(function(_c) { return fn(a, b, _c); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3
             : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) { return fn(_a, _b, c); })
             : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) { return fn(a, _b, _c); })
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b, c); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b, c); })
             : _isPlaceholder(c) ? _curry1(function(_c) { return fn(a, b, _c); })
             : fn(a, b, c);
    }
  };
};

/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * `R.reduced` to shortcut the iteration.
 *
 * The arguments' order of `reduceRight`'s iterator function is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *                -               -10
 *               / \              / \
 *              -   4           -6   4
 *             / \              / \
 *            -   3   ==>     -3   3
 *           / \              / \
 *          -   2           -1   2
 *         / \              / \
 *        0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */
var reduce = _curry3(_reduce);

/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
var _checkForMethod = function _checkForMethod(methodname, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return (_isArray(obj) || typeof obj[methodname] !== 'function') ?
      fn.apply(this, arguments) :
      obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
};

/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
var tail = _curry1(_checkForMethod('tail', slice(1, Infinity)));

/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */
var pipe = function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return _arity(arguments[0].length,
                reduce(_pipe, arguments[0], tail(arguments)));
};

/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curry$1 = _curry1(function curry(fn) {
  return curryN(fn.length, fn);
});

var MAIN = {
    TWITTER_MODES: ['real_time', 'specified_time'],
    TWITTER_MODES_INDEX: {
        'real_time': 0,
        'specified_time': 1
    }
};

var IMAGES = {

    SOC_MEDIA_ICONS: {
        TWITTER: '../../img/icons/twitter_i.png',
        YELP: '',
        FOURSQARE: ''
    }
};

function createIcon(iconUrl) {
    var shadowUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var iconSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [38, 95];
    var shadowSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [50, 64];
    var iconAnchor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [22, 94];
    var shadowIcon = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [4, 62];
    var popupAnchor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-3, -76];

    var twitterIcon = L.icon({
        iconUrl: iconUrl,
        // shadowUrl: IMAGES.SOC_MEDIA_ICONS.TWITTER,

        iconSize: iconSize, // size of the icon
        shadowSize: shadowSize, // size of the shadow
        iconAnchor: iconAnchor, // point of the icon which will correspond to marker's location
        shadowAnchor: shadowIcon, // the same for the shadow
        popupAnchor: popupAnchor // point from which the popup should open relative to the iconAnchor
    });

    console.log('Icon Object: ', twitterIcon);

    return twitterIcon;
}

// export function generateResults(data) {
//     console.log('Data', data);
// }

// export function animateTransition(data) {
//     console.log("")
// }

var generateResults = curry$1(function (data, geo) {
    pipe(map(drawMarker))(data);
});

var drawMarker = curry$1(function (pointData) {
    var twitterIcon = createIcon(IMAGES.SOC_MEDIA_ICONS.TWITTER);

    L.marker([51.5, -0.09], { icon: twitterIcon }).addTo(Map);
});

var drawObject = curry$1(function (data, geolocation, iconType) {
    var icon = void 0;
    switch (iconType) {
        case 'twitter':
            console.log('data, geo, icon:', data, geolocation, iconType);
            icon = createIcon(IMAGES.SOC_MEDIA_ICONS.TWITTER);
            L.marker([geolocation[1], geolocation[0]], { icon: icon }).addTo(Map);
            break;
        case 'yelp':
            console.log('Yelp data, geo, icon', data, geolocation, iconType);
            break;
        default:
            console.log('No soc media was selected.');
    }

    console.log('after switch');
});

/**
 *
 * Control class for handing control panel events
 *
 */

var PanelComponent = function () {
    function PanelComponent(id, name, actionHandler) {
        var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        classCallCheck(this, PanelComponent);

        this.id = id;
        this.name = name;
        this.actionHandler = actionHandler;
        this.data = data;
    }

    createClass(PanelComponent, [{
        key: "getSotedDataBy",
        value: function getSotedDataBy(key) {
            var ascending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            var sortedData = void 0;
            var descComparator = R.comparator(function (a, b) {
                return R.gt(R.prop(key, a), R.prop(key, b));
            });

            sortedData = ascending ? R.sortBy(R.prop(key), this.data) : R.sort(descComparator, this.data);
            return data;
        }
    }, {
        key: "getTopN",
        value: function getTopN(limit, key) {
            var ascending = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

            var formatted = getSortedDataBy(key, ascending);
            return R.slice(0, limit + 1, formatted);
        }
    }, {
        key: "getActionHandler",
        value: function getActionHandler() {
            return this.actionHandler;
        }
    }, {
        key: "getData",
        value: function getData() {
            return this.data;
        }
    }, {
        key: "getId",
        value: function getId() {
            return this.id;
        }
    }, {
        key: "getName",
        value: function getName(name) {
            this.name = name;
        }
    }, {
        key: "setActionHandler",
        value: function setActionHandler(actionHandler) {
            this.actionHandler = actionHandler;
        }
    }, {
        key: "setActionHandler",
        value: function setActionHandler(fn) {
            this.actionHandler = fn;
        }
    }, {
        key: "setData",
        value: function setData(data) {
            this.data = data;
        }
    }, {
        key: "setName",
        value: function setName(name) {
            this.name = name;
        }
    }, {
        key: "toString",
        value: function toString() {
            return {
                "id": this.id,
                "name": this.name,
                "actionHandler": this.actionHandler,
                "data": this.data
            };
        }
    }]);
    return PanelComponent;
}();

var Components = function () {
    function Components() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        classCallCheck(this, Components);

        this.id = id;
        this.name = name;
        this.list = list;
    }

    createClass(Components, [{
        key: "add",
        value: function add(panelComponent) {
            this.list.push(panelComponent);
        }
    }, {
        key: "remove",
        value: function remove(panelComponent) {
            for (var i = 0; i < this.list.length; i++) {
                if (this.list[i].id === panelComponent.id) {
                    this.list.splice(i, 1);
                }
            }
        }
    }, {
        key: "get",
        value: function get$$1() {
            return this;
        }
    }, {
        key: "getId",
        value: function getId() {
            return this.id;
        }
    }, {
        key: "getName",
        value: function getName() {
            return this.name;
        }
    }, {
        key: "getList",
        value: function getList() {
            return this.list;
        }
    }, {
        key: "set",
        value: function set$$1(id, name, list) {
            this.id = id;
            this.name = name;
            this.list = list;
        }
    }, {
        key: "setName",
        value: function setName(name) {
            this.name = name;
        }
    }, {
        key: "setId",
        value: function setId(id) {
            this.id = id;
        }
    }, {
        key: "setList",
        value: function setList(list) {
            this.list = list;
        }
    }, {
        key: "toString",
        value: function toString() {
            return {
                id: this.id,
                name: this.name,
                list: this.list
            };
        }
    }]);
    return Components;
}();

var Mode = function () {
    function Mode(name) {
        classCallCheck(this, Mode);

        this.name = name;
    }

    createClass(Mode, [{
        key: "getName",
        value: function getName() {
            return this.name;
        }
    }, {
        key: "setName",
        value: function setName(name) {
            this.name = name;
        }
    }]);
    return Mode;
}();

var Twitter = function (_Mode) {
    inherits(Twitter, _Mode);

    function Twitter(name) {
        classCallCheck(this, Twitter);
        return possibleConstructorReturn(this, (Twitter.__proto__ || Object.getPrototypeOf(Twitter)).call(this, name));
    }

    createClass(Twitter, [{
        key: 'socketEmit',
        value: function socketEmit(socket, channel, params) {
            socket.emit(channel, params);
        }
    }, {
        key: 'getData',
        value: function getData(url, twitData) {
            return new Promise(function (res, rej) {
                postRequest(url, twitData).then(function (data) {
                    res(data);
                }).catch(function (err) {
                    rej(err);
                });
            });
        }
    }]);
    return Twitter;
}(Mode);

/*=============================================
=            Sentiment class             =
Makes requests to the sentiment API and does
additional processing of the sentiment if needed.
=============================================*/

/*=====  Sentiment Class source  ======*/

var Sentiment = function () {
    function Sentiment(id) {
        classCallCheck(this, Sentiment);

        this.id = id;
    }

    createClass(Sentiment, [{
        key: 'processText',
        value: function processText(sentimentInput) {
            return new Promise(function (res, req) {
                postRequest(getSentimentTextAnalysis(), sentimentInput).then(function (data) {
                    res(data);
                });
            });
        }
    }, {
        key: 'id',
        get: function get$$1() {
            return this._id;
        },
        set: function set$$1(id) {
            this._id = id;
        }
    }]);
    return Sentiment;
}();

// Action
$(window).load(function () {
    var storageSystem = new StorageSystem(window.localStorage);
    var twitter = new Twitter('twitter');
    console.log('twitter', twitter);
    var TWITTER_MODES = MAIN.TWITTER_MODES;
    var TWITTER_MODES_INDEX = MAIN.TWITTER_MODES_INDEX;
    var sentiment = new Sentiment('social_media');

    var socket = io.connect('http://localhost:8000/');

    var cpOpen = void 0,
        tracker = void 0,
        cpRightList = [];

    var rightComponents = new Components();

    /* INTRO LOADER CODE */
    $(function () {
        if (!storageSystem.getItem('firstVisit')) {
            fadeOut('#initLoader', 3000, function () {
                removeElement('#initLoader');
                makeVisible('#mainWrapper', 500);
            });
        } else {
            fadeOut('#initLoader', 550, function () {
                removeElement('#initLoader');
                makeVisible('#mainWrapper', 500);
            });
        }
    });

    storageSystem.setItem('firstVisit', true);

    cpOpen = storageSystem.getItem('cpOpen');
    console.log('cpOpen:::', cpOpen);
    if (cpOpen == 'false') {
        console.log("Should slide: cpOpen", cpOpen);
        slideToggleCp('controlPanelWrapper', Map);
    }

    addEventListenerTo('toggleSliderBtn', 'click', function (event) {
        return slideToggleCp('controlPanelWrapper', Map);
    });

    new L.Control.GPlaceAutocomplete({
        position: 'topright',
        callback: function callback(location) {
            console.log('Location given:', location);
            var lat = location.geometry.location.lat();
            var lng = location.geometry.location.lng();

            // const sanFrancisco = [ '-122.75, 36.8, -121.75, 37.8' ];
            var lastLocation = [lng + ', ' + lat + ', ' + (lng + 1) + ', ' + (lat + 1)];

            storageSystem.setRawItem('lastLocation', lastLocation);
            Map.setView([lat, lng], 8, { animate: true, duration: 2.0 });
        }
    }).addTo(Map);

    socket.on('tweet', function (tweet) {
        var coordinates = tweet.place ? tweet.place.bounding_box.coordinates[0][1] : null;
        if (coordinates) {
            var _coordinates = tweet.place.bounding_box.coordinates[0][1];
            var user = tweet.user;
            var text = tweet.text;
            var id = tweet.id;
            var created_at = tweet.created_at;
            var mlsTime = tweet.timestamp_ms;

            var data = {
                user: user,
                text: text,
                created_at: created_at,
                id: id,
                mlsTime: mlsTime
            };

            // 1. Process sentiment based on passed text
            // 2. Draw an object with metadata on the map
            //    and also draw it on the panel (panel is for future work).
            sentiment.processText({ text: text }).then(function (data) {
                console.log('PROCESSED SENTIMENT OBJECT', data);
                drawObject(data, _coordinates, 'twitter');
            });
        } else {
            console.log('Passed tweet with no coordinates', tweet);
        }
    });

    function getInfoBasedOnChosenMode(mode, query, lastLocation, twitData) {
        switch (mode) {
            case 'real_time':
                twitter.socketEmit(socket, 'topic', { topic: query, location: lastLocation });
                break;
            case 'specified_time':
                twitter.getData(getTwitData(), twitData).then(function (data) {
                    return console.log(data);
                }).catch(function (err) {
                    return new Error('err', err);
                });
                break;
            default:
                console.log('none of the modes selected');

        }
    }

    onSubmit('#querySearchForm', function (e) {
        e.preventDefault();
        var query = getInputValue('#querySearch');
        var lat = Map.getCenter().lat;
        var lng = Map.getCenter().lng;
        var twitData = { q: query, geocode: [lat, lng], radius: '25mi' };

        var lastLocation = [lng + ', ' + lat + ', ' + (lng + 1) + ', ' + (lat + 1)];

        if (isNil(storageSystem.getItem('lastLocation'))) {
            console.log('Not selected. twitData:', twitData);
            // const testTwitDataItemTest = {q: 'trump', geocode: [37.7749, -122.4194], radius: '25mi'};

            getInfoBasedOnChosenMode('real_time', query, lastLocation, twitData);
        } else {
            console.log('Exists', lastLocation);

            /**
                 TODO:
                - This is for General and Selective timing
                - Get data points and draw them on the map
              */
            // const first = GraphOps.generateResults([1, 2, 3, 4]);
            // first(lastLocation);

            /**
                 TODO:
                - This portion of code is for Socket.io/real time tweet streaming
                - Get location and query and start connecting to the socket
              */
            getInfoBasedOnChosenMode('specified_time', query, lastLocation, twitData);
        }

        // last location is saved
        storageSystem.setRawItem('lastLocation', lastLocation);

        // once query selected:
        // check if location is already selected
        // if yes, then go to that location
        //          and show the results
        // if no, then get the center of the current
        //        location of the screen and show the results.
        //
    });

    // generation
    // ui.generateCpRightPanel('#panelWrapper', {});

    // Testing area
    var testGeo = '-25.2744,-133.7751'; // Australia
    // console.log('Path:', Paths.getGeoTrends(testGeo));
    console.log(getGeoTrends(testGeo));
    getRequest(getGeoTrends(testGeo)).then(function (data) {
        if (data.data) {
            var listOfTrends = data.data.trends;
            var geoData = data.geo;

            $("#querySearch").easyAutocomplete({
                data: listOfTrends,
                getValue: 'name',
                list: {
                    match: {
                        enabled: true
                    },
                    onShowListEvent: function onShowListEvent() {
                        // switch(storageSystem.getItem('cpOpen')) {
                        //     case 'false':
                        //        $('.easy-autocomplete-container').addClass('autocomplete-top');
                        //        break;
                        //     case 'true':
                        //        $('.easy-autocomplete-container').removeClass('autocomplete-top');
                        //        break;
                        //     default:
                        //        $('.easy-autocomplete-container').removeClass('autocomplete-top');
                        // };
                        switch (storageSystem.getItem('cpOpen')) {
                            case 'false':
                                addClass('.easy-autocomplete-container', 'autocomplete-top');
                                break;
                            case 'true':
                                removeClass('.easy-autocomplete-container', 'autocomplete-top');
                                break;
                            default:
                                removeClass('.easy-autocomplete-container', 'autocomplete-top');
                        }
                    },
                    onKeyEnterEvent: function onKeyEnterEvent() {}
                }
                // template: {
                //     type: "custom"
                //     // method: function(value, item) {
                //     //     return "<img src='" + item.icon + "' /> | " + item.type + " | " + value;
                //     // }
                // }
            });
        } else {
            console.log("no data", data);
        }

        // (function() {
        //     // for(let i = 0; i < 10; i++) {
        //     //     ui.addElementToPanel
        //     //     (
        //     //         '#panelCompRightWrapper',
        //     //         {},
        //     //         "Button " + i,
        //     //         $('<a></a>'),
        //     //         'menu btn btn-secondary',
        //     //         'col-lg-4'
        //     //     );
        //     // }

        //     // undefined by default will place 'div' element

        //     // ui.addElementTo('')

        // }());

        // console.log('Should reach here...');
        // let dropdown = ui.addContainerToContainer('#panelCompRightWrapper', 'favorites', undefined, 'dropdown show');
        // let $a = ui.addContainerToContainer(dropdown.attr('id'), undefined, $('<a>'), 'btn btn-secondary dropdown-toggle');
        // ui.addTextTo($a, $a.attr('id'));

        //target, dropdownName, dropdownID, dataList


        var panelComp1 = new PanelComponent('#topTen', 'Top 10 Tweets', function () {
            console.log('hi');
        }, [{ "name": "daler" }, { "name": "michael" }]);
        var panelComp2 = new PanelComponent('#topTwenty', 'Top 10 Retweets', function () {
            console.log('hi');
        }, [{ "lastname": "asrorov" }, { "lastname": "jojo" }]);
        var panelComp3 = new PanelComponent('#topThirty', 'Top 30 Retweets', function () {
            console.log('hi');
        }, [{ "jorge": "quero" }, { "sandro": "bolo" }]);

        rightComponents.add(panelComp1);
        rightComponents.add(panelComp2);
        rightComponents.add(panelComp3);
        rightComponents.setName('Social Media');
        rightComponents.setId('socMedia');

        console.log("panelComp object:", rightComponents);
        appendDropDownToPanel('#panelCompRightWrapper', rightComponents);
    }).catch(function (err) {
        console.log("Error request", err);
    });

    var arrayOfIndexes = TWITTER_MODES.map(function (item, index) {
        return index;
    });
    var arrayOfLabels = TWITTER_MODES.map(function (mode) {
        return titleCase(mode.split('_').join(' '));
    });
    appendRangeSlider('#panelCompMiddle', 'range-selector', 'twitterModes', {
        ticks: arrayOfIndexes,
        ticksLabels: arrayOfLabels,
        min: arrayOfIndexes[0],
        max: arrayOfIndexes[arrayOfIndexes.length - 1],
        step: 1,
        value: arrayOfIndexes[0],
        tooltip: 'hide',
        eventHandlers: {
            change: function change(slideEvt) {
                var newMode = slideEvt.value.newValue;
                var prevMode = slideEvt.value.oldValue;
                switch (newMode) {
                    case TWITTER_MODES_INDEX['real_time']:
                        break;
                    case TWITTER_MODES_INDEX['specified_time']:
                        // check the cache
                        // if location data already exists
                        //      return location from cache
                        // else
                        //      store location in cache in (key, value) pair where key is location and value is tweets
                        //      return location
                        var query = getInputValue('#querySearch');
                        var lat = Map.getCenter().lat;
                        var lng = Map.getCenter().lng;
                        var twitData = { q: query, geocode: [lat, lng], radius: '25mi' };
                        twitter.getData(getTwitData(), twitData);
                        break;
                    default:
                        console.log('none selected');

                }
                console.log('Event: change. Slider object', slideEvt);
            }
        }
    });

    // Request.getRequest(Utils.getTrendsPlaces(lat, long))å
    //     .then((data) => {
    //         console.log("Trends Data");
    //     })

    // post request testing

});

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUGxhY2Vob2xkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2lzTmlsLmpzIiwiLi4vanMvbW9kdWxlcy9tYXAuanMiLCIuLi9qcy9jbGFzc2VzL3N0b3JhZ2UuanMiLCIuLi9qcy9jbGFzc2VzL3N0b3JhZ2VzeXN0ZW0uanMiLCIuLi9qcy9tb2R1bGVzL3VpLmpzIiwiLi4vanMvbW9kdWxlcy9yZXF1ZXN0LmpzIiwiLi4vanMvbW9kdWxlcy9wYXRocy5qcyIsIi4uL2pzL21vZHVsZXMvdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNUcmFuc2Zvcm1lci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX21hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3h3cmFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2JpbmQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaXNBcnJheUxpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19yZWR1Y2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZkJhc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194bWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnlOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jdXJyeU4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19oYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0FyZ3VtZW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcGlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5My5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVkdWNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NsaWNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YWlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9waXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jdXJyeS5qcyIsIi4uL2pzL21vZHVsZXMvY29uc3RhbnRzLmpzIiwiLi4vanMvbW9kdWxlcy9tYXBlbGVtZW50cy5qcyIsIi4uL2pzL21vZHVsZXMvbWFwb3BzLmpzIiwiLi4vanMvY2xhc3Nlcy9wYW5lbGNvbXBvbmVudC5qcyIsIi4uL2pzL2NsYXNzZXMvY29tcG9uZW50cy5qcyIsIi4uL2pzL2NsYXNzZXMvbW9kZS5qcyIsIi4uL2pzL2NsYXNzZXMvdHdpdHRlci5qcyIsIi4uL2pzL2NsYXNzZXMvc2VudGltZW50LmpzIiwiLi4vanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1BsYWNlaG9sZGVyKGEpIHtcbiAgcmV0dXJuIGEgIT0gbnVsbCAmJlxuICAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn07XG4iLCJ2YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgb25lLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKDApOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNOaWwoW10pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpc05pbCh4KSB7IHJldHVybiB4ID09IG51bGw7IH0pO1xuIiwiXG4vLyBJbml0aWFsaXppbmcgdGhlIG1hcFxuLy8gbGV0IG1haW5NYXAgPSBMLm1hcCgnbWFwV3JhcHBlcicpLnNldFZpZXcoWzUxLjUwNSwgLTAuMDldLCAxMyk7XG5cbi8vIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywge1xuLy8gICAgIG1heFpvb206IDE5LFxuLy8gICAgIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+J1xuLy8gfSkuYWRkVG8obWFpbk1hcCk7XG5cbmxldCBtYXBMYXllciA9IE1RLm1hcExheWVyKCksIG1haW5NYXA7XG5cbm1haW5NYXAgPSBMLm1hcCgnbWFwV3JhcHBlcicsIHtcbiAgICBsYXllcnM6IG1hcExheWVyLFxuICAgIGNlbnRlcjogWyA0MC43MzE3MDEsIC03My45OTM0MTEgXSxcbiAgICB6b29tOiAxMlxufSk7XG5cbkwuY29udHJvbC5sYXllcnMoe1xuICAnTWFwJzogbWFwTGF5ZXIsXG4gICdIeWJyaWQnOiBNUS5oeWJyaWRMYXllcigpLFxuICAnU2F0ZWxsaXRlJzogTVEuc2F0ZWxsaXRlTGF5ZXIoKSxcbiAgJ0RhcmsnOiBNUS5kYXJrTGF5ZXIoKSxcbiAgJ0xpZ2h0JzogTVEubGlnaHRMYXllcigpXG59KS5hZGRUbyhtYWluTWFwKTtcblxuZXhwb3J0IGRlZmF1bHQgbWFpbk1hcDtcbiIsIi8qKlxuICpcbiAqIFN0b3JhZ2UgQmFzZSBjbGFzc1xuICpcbiAqL1xuXG4gZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBnZXRJdGVtKGtleSkge31cbiAgICBnZXRSYXdJdGVtKGtleSkge31cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHt9XG4gICAgc2V0UmF3SXRlbShrZXksIHZhbHVlKSB7fVxuIH1cbiIsImltcG9ydCBTdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VTeXN0ZW0gZXh0ZW5kcyBTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JhZ2UsIC4uLnJlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuICAgIH1cblxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH1cblxuICAgIGdldFJhd0l0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0SXRlbShrZXkpKTtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0UmF3SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxufSIsIi8vIFVJIFV0aWxzIHNldFxuaW1wb3J0IFN0b3JhZ2VTeXN0ZW0gZnJvbSAnLi8uLi9jbGFzc2VzL3N0b3JhZ2VzeXN0ZW0uanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2xpZGVUb2dnbGVDcCh0YXJnZXRJRCwgbWFwLCBoZWlnaHRTZXR0ZXJJRCA9ICdhcnJvd1BvaW50ZXJXcmFwcGVyJywgY3BEZWZhdWx0SGVpZ2h0ID0gXCIzNSVcIiwgLi4ucmVzdCkge1xuICAgIGNvbnN0IGNwTmF2SGVpZ2h0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGVpZ2h0U2V0dGVySUQpLm9mZnNldEhlaWdodC50b1N0cmluZygpO1xuICAgIGNvbnN0IGNwV3JhcHBlckhlaWdodCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldElEKS5vZmZzZXRIZWlnaHQudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzbGlkaW5nVGltZSA9IDI3MDtcbiAgICBjb25zdCBkZWZhdWx0VG9wID0gXCItMTVweFwiO1xuICAgIGNvbnN0ICRxdWVyeVNlYXJjaEZvcm0gPSAkKCcjcXVlcnlTZWFyY2hGb3JtJyk7XG4gICAgY29uc3QgJHRhcmdldCA9ICQoYCMke3RhcmdldElEfWApO1xuICAgIGNvbnN0ICRib2R5ID0gJCgnYm9keScpO1xuICAgIGNvbnN0ICRzbGlkZVN3aXRjaEljb24gPSAkKCcjc2xpZGVTd2l0Y2hJY29uJyk7XG5cbiAgICBjb25zdCBzdG9yYWdlU3lzdGVtID0gbmV3IFN0b3JhZ2VTeXN0ZW0od2luZG93LmxvY2FsU3RvcmFnZSk7XG5cbiAgICAvL1xuICAgIGlmKGNwV3JhcHBlckhlaWdodCA9PT0gY3BOYXZIZWlnaHQpIHtcbiAgICAgICAgJGJvZHkuY3NzKHtcIm92ZXJmbG93WVwiOiBcImF1dG9cIn0pO1xuICAgICAgICAkdGFyZ2V0LmFuaW1hdGUoe2hlaWdodDogY3BEZWZhdWx0SGVpZ2h0fSwgc2xpZGluZ1RpbWUpO1xuICAgICAgICAkcXVlcnlTZWFyY2hGb3JtLmFuaW1hdGUoe1xuICAgICAgICAgICAgdG9wOiBcIi0xNXB4XCJcbiAgICAgICAgfSwgc2xpZGluZ1RpbWUpO1xuICAgICAgICAkc2xpZGVTd2l0Y2hJY29uLmFkZENsYXNzKCdmYS1jYXJldC1kb3duJykucmVtb3ZlQ2xhc3MoJ2ZhLWNhcmV0LXVwJyk7XG4gICAgICAgIHN0b3JhZ2VTeXN0ZW0uc2V0SXRlbShcImNwT3BlblwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICRib2R5LmNzcyh7XCJvdmVyZmxvd1lcIjogXCJoaWRkZW5cIn0pO1xuICAgICAgICAkdGFyZ2V0LmFuaW1hdGUoe2hlaWdodDogY3BOYXZIZWlnaHR9LCBzbGlkaW5nVGltZSk7XG4gICAgICAgICRxdWVyeVNlYXJjaEZvcm0uYW5pbWF0ZSh7XG4gICAgICAgICAgICB0b3A6IFwiLTM3cHhcIlxuICAgICAgICB9LCBzbGlkaW5nVGltZSk7XG4gICAgICAgIG1hcC5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgICAgICAkc2xpZGVTd2l0Y2hJY29uLmFkZENsYXNzKCdmYS1jYXJldC11cCcpLnJlbW92ZUNsYXNzKCdmYS1jYXJldC1kb3duJyk7XG4gICAgICAgIHN0b3JhZ2VTeXN0ZW0uc2V0SXRlbShcImNwT3BlblwiLCBmYWxzZSk7XG4gICAgfVxufVxuXG4vKipcbiogIEhlbHBlciBVSSBtZXRob2QgdGhhdCB3aWxsIGtlZXAgdGhlXG4qICBjb250cm9sIHBhbmVsIGNsb3NlZCBmYXN0ZXIuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENwQ3NzKHRhcmdldCwgaGVpZ2h0LCBib2R5PSQoJ2JvZHknKSkge1xuICAgIGJvZHkuY3NzKHtcIm92ZXJmbG93WVwiOiBcImF1dG9cIn0pO1xuICAgICR0YXJnZXQuY3NzKHtoZWlnaHQ6IGNwRGVmYXVsdEhlaWdodH0pO1xufVxuXG4vKipcbiogICBCYXNlZCBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IChkaXYpIGFuZCBkYXRhIChsaXN0IG9mXG4qICAgYXZhaWxhYmxlIG9wdGlvbnMpLCBwbGFjZSBhIHRhYmxlIChvciBsaXN0KSBvZlxuKiAgIHdpZGdldHMuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ3BSaWdodFBhbmVsKHRhcmdldCwgZGF0YSkge1xuICAgIGxldCAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgJHRhcmdldC5hcHBlbmRcbiAgICAgICAgKFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2wtbGctNFwiPicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibWVudVwiPicgK1xuICAgICAgICAgICAgICAgICAgICBcIlNvbWV0aGluZ1wiICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEVsZW1lbnRUb1BhbmVsKFxuICAgIHBhbmVsLFxuICAgIGV2ZW50TGlzdGVuZXIsXG4gICAgaHRtbEl0ZW1OYW1lID0gJycsXG4gICAgaHRtbEl0ZW0gPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nKSxcbiAgICBodG1sSXRlbUNsYXNzID0gJ21lbnUnLFxuICAgIGNvbHVtblNpemUgPSAnY29sLWxnLTQnKSB7XG5cbiAgICBsZXQgJHBhbmVsID0gJChwYW5lbCk7XG4gICAgbGV0ICRodG1sSXRlbSA9IGh0bWxJdGVtO1xuICAgIGxldCAkZGl2Q29sID0gJCgnPGRpdj48L2Rpdj4nKTtcblxuICAgICRodG1sSXRlbS5hZGRDbGFzcyhodG1sSXRlbUNsYXNzKTtcbiAgICAkaHRtbEl0ZW0uaHRtbCgnPHNwYW4gY2xhc3M9XCJyaWdodC1jcC1uYW1lXCI+J1xuICAgICAgICAgICAgICAgICAgICsgaHRtbEl0ZW1OYW1lICsgJzwvc3Bhbj4nKVxuICAgICRkaXZDb2wuYWRkQ2xhc3MoY29sdW1uU2l6ZSk7XG5cbiAgICAkZGl2Q29sLmFwcGVuZCgkaHRtbEl0ZW0pO1xuICAgICRwYW5lbC5hcHBlbmQoJGRpdkNvbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFbGVtZW50VG8odGFyZ2V0LCBlbGVtZW50PSQoJzxkaXY+PC9kaXY+JykpIHtcbiAgICBpZih0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICQoYCR7dGFyZ2V0fWApLmFwcGVuZChlbGVtZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbnRhaW5lclRvQ29udGFpbmVyKHBhbmVsLCBpZD0nJywgY29udGFpbmVyPSQoYDxkaXYgaWQ9JHtpZH0+PC9kaXY+YCksIGNsYXNzZXM9JycpIHtcbiAgICBsZXQgYWRkSWQgPSBjb250YWluZXIuYXR0cignaWQnKSA/IGNvbnRhaW5lci5hdHRyKCdpZCcpIDogY29udGFpbmVyLmF0dHIoJ2lkJywgYCMke2lkfWApO1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgY2xhc3Nlcyk7XG4gICAgJChwYW5lbCkuYXBwZW5kKGNvbnRhaW5lcik7XG4gICAgY29uc29sZS5sb2coJ2NvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKHRhcmdldCwgY2xhc3NOYW1lKSB7XG4gICAgJCh0YXJnZXQpLmFkZENsYXNzKGNsYXNzTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRUZXh0VG8odGFyZ2V0LCB0ZXh0KSB7XG4gICAgaWYodHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkpxdWVyeSBzaG91bGQgYmUgYXBwbGllZCBkaXJlY3RseVwiKTtcbiAgICAgICAgdGFyZ2V0Lmh0bWwodGV4dCk7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiB0YXJnZXQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJdCdzIGlkXCIsIHRhcmdldCk7XG4gICAgICAgICQodGFyZ2V0KS5odG1sKHRleHQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKHRhcmdldCwgY2xhc3NOYW1lKSB7XG4gICAgJCh0YXJnZXQpLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBmYWRlT3V0KHRhcmdldCwgdHlwZSwgY2FsbGJhY2tIYW5kbGVyID0gZnVuY3Rpb24oKXt9KSB7XG4vLyAgICAgJCh0YXJnZXQpLmZhZGVPdXQodHlwZSwgY2FsbGJhY2tIYW5kbGVyKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJUbyh0YXJnZXQsIHR5cGUsIGZuKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgJCh0YXJnZXQpLnJlbW92ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGUodGFyZ2V0LCBzdHlsZU9iamVjdCwgLi4ucmVzdCkge1xuICAgIHJldHVybiAkKHRhcmdldCkuY3NzKHN0eWxlT2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGVPdXQodGFyZ2V0LCB0aW1lciwgY2FsbGJhY2spIHtcbiAgICAkKHRhcmdldCkuZmFkZU91dCh0aW1lciwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICQoJyNpbml0TG9hZGVyJykucmVtb3ZlKCk7XG4gICAgICAgIC8vICQoJyNtYWluV3JhcHBlcicpLmNzcyh7b3BhY2l0eTogMC4wLCB2aXNpYmlsaXR5OiBcInZpc2libGVcIn0pLmFuaW1hdGUoe29wYWNpdHk6IDF9LCAxMDAwKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VWaXNpYmxlKHRhcmdldCwgdGltZXIpIHtcbiAgICAkKHRhcmdldCkuY3NzKHtvcGFjaXR5OiAwLjAsIHZpc2liaWxpdHk6IFwidmlzaWJsZVwifSkuYW5pbWF0ZSh7b3BhY2l0eTogMX0sIHRpbWVyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kRHJvcERvd25Ubyh0YXJnZXQsIGRyb3Bkb3duTmFtZSwgZHJvcGRvd25JRCwgYWN0aW9uc0xpc3QpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIkhFUkVcIiwgZHJvcGRvd25OYW1lLCBcIiBIRVJFIFwiLCBkcm9wZG93bklELCBcIiBIRVJFIFwiLCBhY3Rpb25zTGlzdCk7XG4gICAgbGV0ICR0YXJnZXRSZWYgPSAkKHRhcmdldCkuYXBwZW5kKGA8ZGl2IGNsYXNzPVwiZHJvcGRvd25cIiBpZD0ke2Ryb3Bkb3duSUR9PjwvZGl2PmApO1xuICAgIGxldCAkZHJvcGRvd24gPSAkKHRhcmdldCkuZmluZChgIyR7ZHJvcGRvd25JRH1gKTtcbiAgICAkZHJvcGRvd24uYXBwZW5kKGA8YnV0dG9uIGNsYXNzPSdidG4gYnRuLXNlY29uZGFyeSBkcm9wZG93bi10b2dnbGUnIHR5cGU9J2J1dHRvbicgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiPmAgKyBkcm9wZG93bk5hbWUgKyBgPC9idXR0b24+YCk7XG4gICAgbGV0ICRkcm9wZG93blJlZiA9ICRkcm9wZG93bi5hcHBlbmQoYDxkaXYgY2xhc3M9J2Ryb3Bkb3duLW1lbnUnIDwvZGl2PmApO1xuICAgIGxldCAkbGlzdERpdiA9ICRkcm9wZG93blJlZi5maW5kKCcuZHJvcGRvd24tbWVudScpO1xuXG4gICAgYWN0aW9uc0xpc3QubWFwKChhY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICRsaXN0RGl2LmFwcGVuZFxuICAgICAgICAoYFxuICAgICAgICAgICAgPGEgY2xhc3MgPSdkcm9wZG93bi1pdGVtJyBpZD0nJHthY3Rpb24uaWR9JyBocmVmPScjJz4gJHthY3Rpb24ubmFtZX0gPC9hPlxuICAgICAgICBgKVxuICAgIH0pO1xuICAgICRkcm9wZG93bi5hcHBlbmQoJGxpc3REaXYpO1xuICAgICQodGFyZ2V0KS5hcHBlbmQoJGRyb3Bkb3duKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFJhbmdlU2xpZGVyKGNvbnRhaW5lciwgZGl2Q2xhc3MsIGlucHV0SWQsIHBhcmFtcykge1xuICAgIGxldCBuZXdSYW5nZVNsaWRlciA9ICQoXG4gICAgICAgICAgICAgICAgICAgICAgIGA8ZGl2IGNsYXNzPScke2RpdkNsYXNzfSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPScke2lucHV0SWR9JyB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gKTtcbiAgICBsZXQgcmFuZ2VJbnB1dCA9IG5ld1JhbmdlU2xpZGVyLmZpbmQoJ2lucHV0Jyk7XG4gICAgcmFuZ2VJbnB1dC5zbGlkZXIoe1xuICAgICAgICB0aWNrczogcGFyYW1zLnRpY2tzLFxuICAgICAgICB0aWNrc19sYWJlbHM6IHBhcmFtcy50aWNrc0xhYmVscyxcbiAgICAgICAgbWluOiBwYXJhbXMubWluLFxuICAgICAgICBtYXg6IHBhcmFtcy5tYXgsXG4gICAgICAgIHN0ZXA6IHBhcmFtcy5zdGVwLFxuICAgICAgICB2YWx1ZTogcGFyYW1zLnZhbHVlLFxuICAgICAgICB0b29sdGlwOiBwYXJhbXMudG9vbHRpcFxuICAgIH0pO1xuXG4gICAgZm9yKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zLmV2ZW50SGFuZGxlcnMpKSB7XG4gICAgICAgIC8vIGtleSA9PSBldmVudCBhbmQgdmFsdWUgPT0gaGFuZGxlclxuICAgICAgICByYW5nZUlucHV0Lm9uKGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBhcHBlbmRUbyhjb250YWluZXIsIG5ld1JhbmdlU2xpZGVyKTtcbiAgICByYW5nZUlucHV0LnNsaWRlcigncmVmcmVzaCcpO1xuXG4gICAgY29uc29sZS5sb2coYFJhbmdlIHNsaWRlciB3aXRoIGRpdkNsYXNzICcke2RpdkNsYXNzfScnIGlzIGFwcGVuZGVkIHRvICcke2NvbnRhaW5lcn0nYCwgYXBwZW5kVG8oYCR7Y29udGFpbmVyfWAsIG5ld1JhbmdlU2xpZGVyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlwcmVzcyh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgJCh0YXJnZXQpLmtleXByZXNzKGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFRvKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgIHJldHVybiAhISQoYCR7Y29udGFpbmVyfWApLmFwcGVuZChlbGVtZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZERyb3BEb3duVG9QYW5lbCh0YXJnZXQsIGNvbXBvbmVudHNDbGFzcykge1xuICAgIGNvbnNvbGUubG9nKFwiY29tcG9uZW50c0NsYXNzLmxpc3Q6XCIsIGNvbXBvbmVudHNDbGFzcy5saXN0KTtcbiAgICBhcHBlbmREcm9wRG93blRvKHRhcmdldCwgY29tcG9uZW50c0NsYXNzLm5hbWUsIGNvbXBvbmVudHNDbGFzcy5pZCwgY29tcG9uZW50c0NsYXNzLmxpc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25TdWJtaXQodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgICQodGFyZ2V0KS5zdWJtaXQoY2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXRWYWx1ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gJCh0YXJnZXQpLnZhbCgpO1xufVxuXG5cblxuXG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1ZXN0KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgJC5nZXQodXJsLCAoZGF0YSwgc3RhdHVzKSA9PiB7XG5cbiAgICAgICAgICAgIGlmKHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgIHJlcyhkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqKFwiQ291bGRuJ3QgZ2V0IHRoZSBmaWxlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcG9zdFJlcXVlc3QodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAkLnBvc3QodXJsLCBpbmZvLCAoZGF0YSwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZihzdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHJlcyhkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqKFwiVW5zdWNjZXNzZnVsIFBPU1QgcmVxdWVzdC5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59OyIsIlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJlbmRzUGF0aCh3ZWlkKSB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2FwaS90d2l0dGVyL3RyZW5kcy8ke3dlaWR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb1RyZW5kcyhsYXRMb25nU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2FwaS90d2l0dGVyL2dlb3RyZW5kcy8ke2xhdExvbmdTdHJpbmd9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR3aXREYXRhKCkge1xuICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hcGkvdHdpdHRlci90d2l0ZGF0YWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW50aW1lbnRUZXh0QW5hbHlzaXMoKSB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2FwaS9zZW50aW1lbnQvZXZhbHVhdGVzdHJpbmdgO1xufVxuXG4iLCJcblxuZXhwb3J0IGZ1bmN0aW9uIHRpdGxlQ2FzZShzdHIpIHtcbiAgICBjb25zdCBlc2NhcGVSZWcgPSBzID0+IHMucmVwbGFjZSgvLi9nLCBjID0+IGBcXFxcJHtjfWApO1xuICAgIGxldCB3b3JkUGF0dGVybiA9IG5ldyBSZWdFeHAoYFteJHtlc2NhcGVSZWcoJyBfLcKhwr8vJyl9XStgLCAnZycpO1xuICAgIGxldCByZXN1bHQgPSBzdHIucmVwbGFjZSh3b3JkUGF0dGVybiwgY2FwaXRhbGl6ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjV2l0aFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUsIHNlbGVjdG9yPVwiXCIpIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjV2l0aEludGVydmFsKGNhbGxiYWNrLCB0aW1lLCBzZWxlY3Rvcj1cIlwiKSB7XG4gICAgc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRpbWUpXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn0iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vX2N1cnJ5MScpO1xudmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5Mihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjIoYSwgYikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjI7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYyXG4gICAgICAgICAgICAgOiBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7IHJldHVybiBmbihhLCBfYik7IH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjJcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbihfYSkgeyByZXR1cm4gZm4oX2EsIGIpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7IHJldHVybiBmbihhLCBfYik7IH0pXG4gICAgICAgICAgICAgOiBmbihhLCBiKTtcbiAgICB9XG4gIH07XG59O1xuIiwiLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsYCBpcyBhbiBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXkoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXkoe30pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBfaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuICh2YWwgIT0gbnVsbCAmJlxuICAgICAgICAgIHZhbC5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1RyYW5zZm9ybWVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9ialsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL19pc0FycmF5Jyk7XG52YXIgX2lzVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL19pc1RyYW5zZm9ybWVyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIHdpdGggZGlmZmVyZW50IHN0cmF0ZWdpZXMgYmFzZWQgb24gdGhlXG4gKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICogT3RoZXJ3aXNlLCBpZiBpdCBoYXMgYSBmdW5jdGlvbiB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbWV0aG9kIG5hbWVzLCBpdCB3aWxsXG4gKiBleGVjdXRlIHRoYXQgZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lcixcbiAqIHVzZXMgdHJhbnNkdWNlciBbeGZdIHRvIHJldHVybiBhIG5ldyB0cmFuc2Zvcm1lciAodHJhbnNkdWNlciBjYXNlKS5cbiAqIE90aGVyd2lzZSwgaXQgd2lsbCBkZWZhdWx0IHRvIGV4ZWN1dGluZyBbZm5dLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBtZXRob2ROYW1lcyBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgdHJhbnNkdWNlciB0byBpbml0aWFsaXplIGlmIG9iamVjdCBpcyB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZGVmYXVsdCByYW1kYSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2Rpc3BhdGNoYWJsZShtZXRob2ROYW1lcywgeGYsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB2YXIgb2JqID0gYXJncy5wb3AoKTtcbiAgICBpZiAoIV9pc0FycmF5KG9iaikpIHtcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgd2hpbGUgKGlkeCA8IG1ldGhvZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2ROYW1lc1tpZHhdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0uYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX21hcChmbiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYV3JhcChmbikge1xuICAgIHRoaXMuZiA9IGZuO1xuICB9XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBub3QgaW1wbGVtZW50ZWQgb24gWFdyYXAnKTtcbiAgfTtcbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihhY2MpIHsgcmV0dXJuIGFjYzsgfTtcbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIHRoaXMuZihhY2MsIHgpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBfeHdyYXAoZm4pIHsgcmV0dXJuIG5ldyBYV3JhcChmbik7IH07XG59KCkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfYXJpdHkobiwgZm4pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEwKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDY6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNzogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgODogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDk6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMTA6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59O1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG8gYSBjb250ZXh0LlxuICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICogW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKiAtPiAqKSAtPiB7Kn0gLT4gKCogLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzT2JqIFRoZSBjb250ZXh0IHRvIGJpbmQgYGZuYCB0b1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgYHRoaXNPYmpgLlxuICogQHNlZSBSLnBhcnRpYWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbG9nID0gUi5iaW5kKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAqICAgICAgUi5waXBlKFIuYXNzb2MoJ2EnLCAyKSwgUi50YXAobG9nKSwgUi5hc3NvYygnYScsIDMpKSh7YTogMX0pOyAvLz0+IHthOiAzfVxuICogICAgICAvLyBsb2dzIHthOiAyfVxuICogQHN5bWIgUi5iaW5kKGYsIG8pKGEsIGIpID0gZi5jYWxsKG8sIGEsIGIpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc09iaiwgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzU3RyaW5nKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJyYXknKTtcbnZhciBfaXNTdHJpbmcgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc1N0cmluZycpO1xuXG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNS4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHggVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBoYXMgYSBudW1lcmljIGxlbmd0aCBwcm9wZXJ0eSBhbmQgZXh0cmVtZSBpbmRpY2VzIGRlZmluZWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjMuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNBcnJheUxpa2UoW10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5pc0FycmF5TGlrZSh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHt9KTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHtsZW5ndGg6IDEwfSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0FycmF5TGlrZSh7MDogJ3plcm8nLCA5OiAnbmluZScsIGxlbmd0aDogMTB9KTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpc0FycmF5TGlrZSh4KSB7XG4gIGlmIChfaXNBcnJheSh4KSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAoIXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChfaXNTdHJpbmcoeCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICh4Lm5vZGVUeXBlID09PSAxKSB7IHJldHVybiAhIXgubGVuZ3RoOyB9XG4gIGlmICh4Lmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAoeC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHguaGFzT3duUHJvcGVydHkoMCkgJiYgeC5oYXNPd25Qcm9wZXJ0eSh4Lmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pO1xuIiwidmFyIF94d3JhcCA9IHJlcXVpcmUoJy4vX3h3cmFwJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2JpbmQnKTtcbnZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2lzQXJyYXlMaWtlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIF9hcnJheVJlZHVjZSh4ZiwgYWNjLCBsaXN0KSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgbGlzdFtpZHhdKTtcbiAgICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVSZWR1Y2UoeGYsIGFjYywgaXRlcikge1xuICAgIHZhciBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgc3RlcC52YWx1ZSk7XG4gICAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9tZXRob2RSZWR1Y2UoeGYsIGFjYywgb2JqKSB7XG4gICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ob2JqLnJlZHVjZShiaW5kKHhmWydAQHRyYW5zZHVjZXIvc3RlcCddLCB4ZiksIGFjYykpO1xuICB9XG5cbiAgdmFyIHN5bUl0ZXJhdG9yID0gKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJztcbiAgcmV0dXJuIGZ1bmN0aW9uIF9yZWR1Y2UoZm4sIGFjYywgbGlzdCkge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuID0gX3h3cmFwKGZuKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKGxpc3QpKSB7XG4gICAgICByZXR1cm4gX2FycmF5UmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpc3QucmVkdWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gX21ldGhvZFJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgaWYgKGxpc3Rbc3ltSXRlcmF0b3JdICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGlzdC5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xuICB9O1xufSgpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfVxufTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYTWFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmYoaW5wdXQpKTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeG1hcChmLCB4ZikgeyByZXR1cm4gbmV3IFhNYXAoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9fYXJpdHknKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggJiZcbiAgICAgICAgICAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHxcbiAgICAgICAgICAgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbYXJnc0lkeF07XG4gICAgICAgIGFyZ3NJZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbWJpbmVkW2NvbWJpbmVkSWR4XSA9IHJlc3VsdDtcbiAgICAgIGlmICghX2lzUGxhY2Vob2xkZXIocmVzdWx0KSkge1xuICAgICAgICBsZWZ0IC09IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdCA8PSAwID8gZm4uYXBwbHkodGhpcywgY29tYmluZWQpXG4gICAgICAgICAgICAgICAgICAgICA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59O1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfY3VycnlOID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnlOJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgY3VycmllZCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBhcml0eS4gVGhlIGN1cnJpZWQgZnVuY3Rpb24gaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0c1xuICogYXJndW1lbnRzIG5lZWRuJ3QgYmUgcHJvdmlkZWQgb25lIGF0IGEgdGltZS4gSWYgYGdgIGlzIGBSLmN1cnJ5TigzLCBmKWAsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxKSgyKSgzKWBcbiAqICAgLSBgZygxKSgyLCAzKWBcbiAqICAgLSBgZygxLCAyKSgzKWBcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqXG4gKiBTZWNvbmRseSwgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgYFIuX19gIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgYFIuX19gLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gKlxuICogICAgICB2YXIgY3VycmllZEFkZEZvdXJOdW1iZXJzID0gUi5jdXJyeU4oNCwgc3VtQXJncyk7XG4gKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICogICAgICB2YXIgZyA9IGYoMyk7XG4gKiAgICAgIGcoNCk7IC8vPT4gMTBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGN1cnJ5TihsZW5ndGgsIGZuKSB7XG4gIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gX2N1cnJ5MShmbik7XG4gIH1cbiAgcmV0dXJuIF9hcml0eShsZW5ndGgsIF9jdXJyeU4obGVuZ3RoLCBbXSwgZm4pKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaGFzKHByb3AsIG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59O1xuIiwidmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgP1xuICAgIGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7IHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJzsgfSA6XG4gICAgZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHsgcmV0dXJuIF9oYXMoJ2NhbGxlZScsIHgpOyB9O1xufSgpKTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xudmFyIF9pc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJndW1lbnRzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2ZcbiAqIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBba11cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmtleXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xuICB2YXIgaGFzRW51bUJ1ZyA9ICEoe3RvU3RyaW5nOiBudWxsfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ2NvbnN0cnVjdG9yJywgJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG4gIC8vIFNhZmFyaSBidWdcbiAgdmFyIGhhc0FyZ3NFbnVtQnVnID0gKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbiAgfSgpKTtcblxuICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICBpZiAobGlzdFtpZHhdID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/XG4gICAgX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfSkgOlxuICAgIF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wLCBuSWR4O1xuICAgICAgdmFyIGtzID0gW107XG4gICAgICB2YXIgY2hlY2tBcmdzTGVuZ3RoID0gaGFzQXJnc0VudW1CdWcgJiYgX2lzQXJndW1lbnRzKG9iaik7XG4gICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgKCFjaGVja0FyZ3NMZW5ndGggfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG4gICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNFbnVtQnVnKSB7XG4gICAgICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKG5JZHggPj0gMCkge1xuICAgICAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG4gICAgICAgICAgaWYgKF9oYXMocHJvcCwgb2JqKSAmJiAhY29udGFpbnMoa3MsIHByb3ApKSB7XG4gICAgICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbklkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga3M7XG4gICAgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfeG1hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3htYXAnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kXG4gKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICogYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBvZiB0aGUgZnVuY3RvcidzIHZhbHVlcywgYW5kIHJldHVybnNcbiAqIGEgZnVuY3RvciBvZiB0aGUgc2FtZSBzaGFwZS5cbiAqXG4gKiBSYW1kYSBwcm92aWRlcyBzdWl0YWJsZSBgbWFwYCBpbXBsZW1lbnRhdGlvbnMgZm9yIGBBcnJheWAgYW5kIGBPYmplY3RgLFxuICogc28gdGhpcyBmdW5jdGlvbiBtYXkgYmUgYXBwbGllZCB0byBgWzEsIDIsIDNdYCBvciBge3g6IDEsIHk6IDIsIHo6IDN9YC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgbWFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQWxzbyB0cmVhdHMgZnVuY3Rpb25zIGFzIGZ1bmN0b3JzIGFuZCB3aWxsIGNvbXBvc2UgdGhlbSB0b2dldGhlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGxpc3QuXG4gKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRvdWJsZSA9IHggPT4geCAqIDI7XG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIFsxLCAyLCAzXSk7IC8vPT4gWzIsIDQsIDZdXG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIHt4OiAxLCB5OiAyLCB6OiAzfSk7IC8vPT4ge3g6IDIsIHk6IDQsIHo6IDZ9XG4gKiBAc3ltYiBSLm1hcChmLCBbYSwgYl0pID0gW2YoYSksIGYoYildXG4gKiBAc3ltYiBSLm1hcChmLCB7IHg6IGEsIHk6IGIgfSkgPSB7IHg6IGYoYSksIHk6IGYoYikgfVxuICogQHN5bWIgUi5tYXAoZiwgZnVuY3Rvcl9vKSA9IGZ1bmN0b3Jfby5tYXAoZilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydtYXAnXSwgX3htYXAsIGZ1bmN0aW9uIG1hcChmbiwgZnVuY3Rvcikge1xuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jdG9yKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzpcbiAgICAgIHJldHVybiBjdXJyeU4oZnVuY3Rvci5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZ1bmN0b3IpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICB9XG59KSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9waXBlKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnLmNhbGwodGhpcywgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn07XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vX2N1cnJ5MScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYzXG4gICAgICAgICAgICAgOiBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykgeyByZXR1cm4gZm4oYSwgX2IsIF9jKTsgfSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYzXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2EsIF9jKSB7IHJldHVybiBmbihfYSwgYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykgeyByZXR1cm4gZm4oYSwgX2IsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IF9jdXJyeTEoZnVuY3Rpb24oX2MpIHsgcmV0dXJuIGZuKGEsIGIsIF9jKTsgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmM1xuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uKF9hLCBfYikgeyByZXR1cm4gZm4oX2EsIF9iLCBjKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbihfYSwgX2MpIHsgcmV0dXJuIGZuKF9hLCBiLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2IsIF9jKSB7IHJldHVybiBmbihhLCBfYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uKF9hKSB7IHJldHVybiBmbihfYSwgYiwgYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iLCBjKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbihfYykgeyByZXR1cm4gZm4oYSwgYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogZm4oYSwgYiwgYyk7XG4gICAgfVxuICB9O1xufTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICogdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGl0IGFuIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgY3VycmVudFxuICogdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKGFjYywgdmFsdWUpKi4gSXQgbWF5IHVzZVxuICogYFIucmVkdWNlZGAgdG8gc2hvcnRjdXQgdGhlIGl0ZXJhdGlvbi5cbiAqXG4gKiBUaGUgYXJndW1lbnRzJyBvcmRlciBvZiBgcmVkdWNlUmlnaHRgJ3MgaXRlcmF0b3IgZnVuY3Rpb24gaXMgKih2YWx1ZSwgYWNjKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlZCwgUi5hZGRJbmRleCwgUi5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKCgoKDAgLSAxKSAtIDIpIC0gMykgLSA0KSA9IC0xMFxuICogICAgICAgICAgICAgICAgLSAgICAgICAgICAgICAgIC0xMFxuICogICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgICAgICAgICAgLSAgIDQgICAgICAgICAgIC02ICAgNFxuICogICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAtICAgMyAgID09PiAgICAgLTMgICAzXG4gKiAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgLSAgIDIgICAgICAgICAgIC0xICAgMlxuICogICAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgICAgMCAgIDEgICAgICAgICAgICAwICAgMVxuICpcbiAqIEBzeW1iIFIucmVkdWNlKGYsIGEsIFtiLCBjLCBkXSkgPSBmKGYoZihhLCBiKSwgYyksIGQpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhfcmVkdWNlKTtcbiIsInZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzQXJyYXknKTtcblxuXG4vKipcbiAqIFRoaXMgY2hlY2tzIHdoZXRoZXIgYSBmdW5jdGlvbiBoYXMgYSBbbWV0aG9kbmFtZV0gZnVuY3Rpb24uIElmIGl0IGlzbid0IGFuXG4gKiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSByYW1kYVxuICogaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHJhbWRhIGltcGxlbXRhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZG5hbWUgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY2hlY2tGb3JNZXRob2QobWV0aG9kbmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiAoX2lzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSAnZnVuY3Rpb24nKSA/XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDpcbiAgICAgIG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgbGVuZ3RoIC0gMSkpO1xuICB9O1xufTtcbiIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0IHdpdGggYSBgc2xpY2VgXG4gKiBtZXRob2QpIGZyb20gYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gYHRvSW5kZXhgIChleGNsdXNpdmUpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjRcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXggVGhlIHN0YXJ0IGluZGV4IChpbmNsdXNpdmUpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXggVGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKS5cbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNsaWNlKDEsIDMsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDEsIEluZmluaXR5LCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7IC8vPT4gWydiJywgJ2MnLCAnZCddXG4gKiAgICAgIFIuc2xpY2UoMCwgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgUi5zbGljZSgtMywgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAvLz0+IFsnYicsICdjJ11cbiAqICAgICAgUi5zbGljZSgwLCAzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAgICAgICAvLz0+ICdyYW0nXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhfY2hlY2tGb3JNZXRob2QoJ3NsaWNlJywgZnVuY3Rpb24gc2xpY2UoZnJvbUluZGV4LCB0b0luZGV4LCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xufSkpO1xuIiwidmFyIF9jaGVja0Zvck1ldGhvZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJyk7XG52YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0XG4gKiB3aXRoIGEgYHRhaWxgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaGVhZCwgUi5pbml0LCBSLmxhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRhaWwoWzEsIDIsIDNdKTsgIC8vPT4gWzIsIDNdXG4gKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAqICAgICAgUi50YWlsKFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIudGFpbChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi50YWlsKCdhYmMnKTsgIC8vPT4gJ2JjJ1xuICogICAgICBSLnRhaWwoJ2FiJyk7ICAgLy89PiAnYidcbiAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi50YWlsKCcnKTsgICAgIC8vPT4gJydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9jaGVja0Zvck1ldGhvZCgndGFpbCcsIHNsaWNlKDEsIEluZmluaXR5KSkpO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX3BpcGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19waXBlJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB0YWlsID0gcmVxdWlyZSgnLi90YWlsJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgbGVmdG1vc3QgZnVuY3Rpb24gbWF5IGhhdmVcbiAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBzZXF1ZW5jZWAuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoKGEsIGIsIC4uLiwgbikgLT4gbyksIChvIC0+IHApLCAuLi4sICh4IC0+IHkpLCAoeSAtPiB6KSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAqXG4gKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAqIEBzeW1iIFIucGlwZShmLCBnLCBoKShhLCBiKSA9IGgoZyhmKGEsIGIpKSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVkdWNlKF9waXBlLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGUgY3VycmllZCBmdW5jdGlvblxuICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAqIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzIGBSLmN1cnJ5KGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRGb3VyTnVtYmVycyA9IChhLCBiLCBjLCBkKSA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnkoYWRkRm91ck51bWJlcnMpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBjdXJyeShmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZm4pO1xufSk7XG4iLCJleHBvcnQgY29uc3QgTUFJTiA9IHtcbiAgICBUV0lUVEVSX01PREVTOiBbJ3JlYWxfdGltZScsICdzcGVjaWZpZWRfdGltZSddLFxuICAgIFRXSVRURVJfTU9ERVNfSU5ERVg6IHtcbiAgICAgICAgJ3JlYWxfdGltZSc6IDAsXG4gICAgICAgICdzcGVjaWZpZWRfdGltZSc6IDFcbiAgICB9XG59XG5cblxuZXhwb3J0IGNvbnN0IElNQUdFUyA9IHtcblxuICAgIFNPQ19NRURJQV9JQ09OUzoge1xuICAgICAgICBUV0lUVEVSOiAnLi4vLi4vaW1nL2ljb25zL3R3aXR0ZXJfaS5wbmcnLFxuICAgICAgICBZRUxQOiAnJyxcbiAgICAgICAgRk9VUlNRQVJFOiAnJ1xuICAgIH1cbn1cbiIsIlxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSWNvbihpY29uVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VXJsPVwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU2l6ZT1bMzgsIDk1XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1NpemU9WzUwLCA2NF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uQW5jaG9yPVsyMiwgOTRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93SWNvbj0gWzQsIDYyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwQW5jaG9yPVstMywgLTc2XSkge1xuICAgIGxldCB0d2l0dGVySWNvbiA9IEwuaWNvbih7XG4gICAgICAgIGljb25Vcmw6IGljb25VcmwsXG4gICAgICAgIC8vIHNoYWRvd1VybDogSU1BR0VTLlNPQ19NRURJQV9JQ09OUy5UV0lUVEVSLFxuXG4gICAgICAgIGljb25TaXplOiAgICAgaWNvblNpemUsIC8vIHNpemUgb2YgdGhlIGljb25cbiAgICAgICAgc2hhZG93U2l6ZTogICBzaGFkb3dTaXplLCAvLyBzaXplIG9mIHRoZSBzaGFkb3dcbiAgICAgICAgaWNvbkFuY2hvcjogICBpY29uQW5jaG9yLCAvLyBwb2ludCBvZiB0aGUgaWNvbiB3aGljaCB3aWxsIGNvcnJlc3BvbmQgdG8gbWFya2VyJ3MgbG9jYXRpb25cbiAgICAgICAgc2hhZG93QW5jaG9yOiBzaGFkb3dJY29uLCAgLy8gdGhlIHNhbWUgZm9yIHRoZSBzaGFkb3dcbiAgICAgICAgcG9wdXBBbmNob3I6ICBwb3B1cEFuY2hvciAvLyBwb2ludCBmcm9tIHdoaWNoIHRoZSBwb3B1cCBzaG91bGQgb3BlbiByZWxhdGl2ZSB0byB0aGUgaWNvbkFuY2hvclxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ0ljb24gT2JqZWN0OiAnLCB0d2l0dGVySWNvbik7XG5cbiAgICByZXR1cm4gdHdpdHRlckljb247XG59IiwiaW1wb3J0IE1hcCBmcm9tICcuL21hcC5qcyc7XG5pbXBvcnQgeyBJTUFHRVMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyBNYXBFbGVtZW50cyBmcm9tICcuL21hcGVsZW1lbnRzLmpzJztcbmltcG9ydCB7Y3VycnksIG1hcCwgcGlwZX0gZnJvbSAncmFtZGEnO1xuXG4vLyBleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXN1bHRzKGRhdGEpIHtcbi8vICAgICBjb25zb2xlLmxvZygnRGF0YScsIGRhdGEpO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYW5pbWF0ZVRyYW5zaXRpb24oZGF0YSkge1xuLy8gICAgIGNvbnNvbGUubG9nKFwiXCIpXG4vLyB9XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJlc3VsdHMgPSBjdXJyeSgoZGF0YSwgZ2VvKSA9PiB7XG4gICAgcGlwZShcbiAgICAgICAgbWFwKGRyYXdNYXJrZXIpLCAvLyByZW5kZXIgcG9pbnRzIHdpdGggYW5pbWF0aW9uc1xuICAgICkoZGF0YSk7XG59KTtcblxuZXhwb3J0IGNvbnN0IGRyYXdNYXJrZXIgPSBjdXJyeSgocG9pbnREYXRhKSA9PiB7XG4gICAgY29uc3QgdHdpdHRlckljb24gPSBNYXBFbGVtZW50cy5jcmVhdGVJY29uKElNQUdFUy5TT0NfTUVESUFfSUNPTlMuVFdJVFRFUik7XG5cbiAgICBMLm1hcmtlcihbNTEuNSwgLTAuMDldLCB7aWNvbjogdHdpdHRlckljb259KS5hZGRUbyhNYXApO1xufSk7XG5cbmV4cG9ydCBjb25zdCBkcmF3T2JqZWN0ID0gY3VycnkoKGRhdGEsIGdlb2xvY2F0aW9uLCBpY29uVHlwZSkgPT4ge1xuICAgIGxldCBpY29uO1xuICAgIHN3aXRjaChpY29uVHlwZSkge1xuICAgICAgICBjYXNlICd0d2l0dGVyJzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkYXRhLCBnZW8sIGljb246JywgZGF0YSwgZ2VvbG9jYXRpb24sIGljb25UeXBlKTtcbiAgICAgICAgICAgIGljb24gPSBNYXBFbGVtZW50cy5jcmVhdGVJY29uKElNQUdFUy5TT0NfTUVESUFfSUNPTlMuVFdJVFRFUik7XG4gICAgICAgICAgICBMLm1hcmtlcihbZ2VvbG9jYXRpb25bMV0sIGdlb2xvY2F0aW9uWzBdXSwge2ljb246IGljb259KS5hZGRUbyhNYXApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3llbHAnOlxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1llbHAgZGF0YSwgZ2VvLCBpY29uJywgZGF0YSwgZ2VvbG9jYXRpb24sIGljb25UeXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHNvYyBtZWRpYSB3YXMgc2VsZWN0ZWQuJyk7XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdhZnRlciBzd2l0Y2gnKTtcbn0pOyIsIi8qKlxuICpcbiAqIENvbnRyb2wgY2xhc3MgZm9yIGhhbmRpbmcgY29udHJvbCBwYW5lbCBldmVudHNcbiAqXG4gKi9cblxuIGV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhbmVsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgbmFtZSwgYWN0aW9uSGFuZGxlciwgZGF0YT1bXSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IGFjdGlvbkhhbmRsZXI7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0U290ZWREYXRhQnkoa2V5LCBhc2NlbmRpbmc9dHJ1ZSkge1xuICAgICAgICBsZXQgc29ydGVkRGF0YTtcbiAgICAgICAgY29uc3QgZGVzY0NvbXBhcmF0b3IgPSBSLmNvbXBhcmF0b3IoKGEsIGIpID0+IFIuZ3QoUi5wcm9wKGtleSwgYSksIFIucHJvcChrZXksIGIpKSk7XG5cbiAgICAgICAgc29ydGVkRGF0YSA9IGFzY2VuZGluZyA/IFIuc29ydEJ5KFIucHJvcChrZXkpLCB0aGlzLmRhdGEpIDogUi5zb3J0KGRlc2NDb21wYXJhdG9yLCB0aGlzLmRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUb3BOKGxpbWl0LCBrZXksIGFzY2VuZGluZz10cnVlKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBnZXRTb3J0ZWREYXRhQnkoa2V5LCBhc2NlbmRpbmcpO1xuICAgICAgICByZXR1cm4gUi5zbGljZSgwLCBsaW1pdCArIDEsIGZvcm1hdHRlZCk7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG5cbiAgICBnZXROYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICBzZXRBY3Rpb25IYW5kbGVyKGFjdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gYWN0aW9uSGFuZGxlcjtcbiAgICB9XG5cbiAgICBzZXRBY3Rpb25IYW5kbGVyKGZuKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IGZuO1xuICAgIH1cblxuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIHNldE5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmlkLFxuICAgICAgICAgICAgXCJuYW1lXCI6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIFwiYWN0aW9uSGFuZGxlclwiOiB0aGlzLmFjdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICBcImRhdGFcIjogdGhpcy5kYXRhXG4gICAgICAgIH07XG4gICAgfVxuIH1cbiIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50cyB7XG4gICAgY29uc3RydWN0b3IoaWQ9XCJcIiwgbmFtZT1cIlwiLCBsaXN0PVtdKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICBhZGQocGFuZWxDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5saXN0LnB1c2gocGFuZWxDb21wb25lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShwYW5lbENvbXBvbmVudCkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0aGlzLmxpc3RbaV0uaWQgPT09IHBhbmVsQ29tcG9uZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cblxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgZ2V0TGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdDtcbiAgICB9XG5cbiAgICBzZXQoaWQsIG5hbWUsIGxpc3QpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIH1cblxuICAgIHNldE5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIHNldElkKGlkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG5cbiAgICBzZXRMaXN0KGxpc3QpIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGlzdDogdGhpcy5saXN0XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cblxuICAgIHNldE5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn0iLCJpbXBvcnQgTW9kZSBmcm9tICcuL21vZGUuanMnO1xuaW1wb3J0ICogYXMgUmVxdWVzdCBmcm9tICcuLi9tb2R1bGVzL3JlcXVlc3QuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2l0dGVyIGV4dGVuZHMgTW9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICB9XG5cbiAgICBzb2NrZXRFbWl0KHNvY2tldCwgY2hhbm5lbCwgcGFyYW1zKSB7XG4gICAgICAgIHNvY2tldC5lbWl0KGNoYW5uZWwsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgZ2V0RGF0YSh1cmwsIHR3aXREYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIFJlcXVlc3QucG9zdFJlcXVlc3QodXJsLCB0d2l0RGF0YSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzKGRhdGEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsIlxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbj0gICAgICAgICAgICBTZW50aW1lbnQgY2xhc3MgICAgICAgICAgICAgPVxuTWFrZXMgcmVxdWVzdHMgdG8gdGhlIHNlbnRpbWVudCBBUEkgYW5kIGRvZXNcbmFkZGl0aW9uYWwgcHJvY2Vzc2luZyBvZiB0aGUgc2VudGltZW50IGlmIG5lZWRlZC5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8qPT09PT0gIFNlbnRpbWVudCBDbGFzcyBzb3VyY2UgID09PT09PSovXG5cbmltcG9ydCB7IGdldFJlcXVlc3QsIHBvc3RSZXF1ZXN0IH0gZnJvbSAnLi4vbW9kdWxlcy9yZXF1ZXN0LmpzJztcbmltcG9ydCB7IGdldFNlbnRpbWVudFRleHRBbmFseXNpcyB9IGZyb20gJy4uL21vZHVsZXMvcGF0aHMuanMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbnRpbWVudCB7XG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cblxuICAgIHNldCBpZChpZCkge1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgIH1cblxuICAgIHByb2Nlc3NUZXh0KHNlbnRpbWVudElucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZXEpID0+IHtcbiAgICAgICAgICAgIHBvc3RSZXF1ZXN0KGdldFNlbnRpbWVudFRleHRBbmFseXNpcygpLCBzZW50aW1lbnRJbnB1dClcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gJy4vbW9kdWxlcy9tYXAuanMnO1xuaW1wb3J0ICogYXMgdWkgZnJvbSAnLi9tb2R1bGVzL3VpLmpzJztcbmltcG9ydCAqIGFzIFJlcXVlc3QgZnJvbSAnLi9tb2R1bGVzL3JlcXVlc3QuanMnO1xuaW1wb3J0ICogYXMgUGF0aHMgZnJvbSAnLi9tb2R1bGVzL3BhdGhzLmpzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vbW9kdWxlcy91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBHcmFwaE9wcyBmcm9tICcuL21vZHVsZXMvbWFwb3BzLmpzJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL21vZHVsZXMvY29uc3RhbnRzLmpzJztcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vY2xhc3Nlcy9zdG9yYWdlLmpzJztcbmltcG9ydCBTdG9yYWdlU3lzdGVtIGZyb20gJy4vY2xhc3Nlcy9zdG9yYWdlc3lzdGVtLmpzJztcbmltcG9ydCBQYW5lbENvbXBvbmVudCBmcm9tICcuL2NsYXNzZXMvcGFuZWxjb21wb25lbnQuanMnO1xuaW1wb3J0IENvbXBvbmVudHMgZnJvbSAnLi9jbGFzc2VzL2NvbXBvbmVudHMuanMnO1xuaW1wb3J0IFR3aXR0ZXIgZnJvbSAnLi9jbGFzc2VzL3R3aXR0ZXIuanMnO1xuaW1wb3J0IFNlbnRpbWVudCBmcm9tICcuL2NsYXNzZXMvc2VudGltZW50LmpzJztcbmltcG9ydCBSIGZyb20gJ3JhbWRhJztcblxuLy8gQWN0aW9uXG4kKHdpbmRvdykubG9hZChmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzdG9yYWdlU3lzdGVtID0gbmV3IFN0b3JhZ2VTeXN0ZW0od2luZG93LmxvY2FsU3RvcmFnZSk7XG4gICAgY29uc3QgdHdpdHRlciA9IG5ldyBUd2l0dGVyKCd0d2l0dGVyJyk7XG4gICAgY29uc29sZS5sb2coJ3R3aXR0ZXInLCB0d2l0dGVyKTtcbiAgICBjb25zdCBUV0lUVEVSX01PREVTID0gY29uc3RhbnRzLk1BSU4uVFdJVFRFUl9NT0RFUztcbiAgICBjb25zdCBUV0lUVEVSX01PREVTX0lOREVYID0gY29uc3RhbnRzLk1BSU4uVFdJVFRFUl9NT0RFU19JTkRFWDtcbiAgICBjb25zdCBzZW50aW1lbnQgPSBuZXcgU2VudGltZW50KCdzb2NpYWxfbWVkaWEnKTtcblxuICAgIGxldCBzb2NrZXQgPSBpby5jb25uZWN0KCdodHRwOi8vbG9jYWxob3N0OjgwMDAvJyk7XG5cbiAgICBsZXQgY3BPcGVuLFxuICAgICAgICB0cmFja2VyLFxuICAgICAgICBjcFJpZ2h0TGlzdCA9W107XG5cbiAgICBsZXQgcmlnaHRDb21wb25lbnRzID0gbmV3IENvbXBvbmVudHMoKTtcblxuICAgIC8qIElOVFJPIExPQURFUiBDT0RFICovXG4gICAgJCgoKSA9PiB7XG4gICAgICAgIGlmKCFzdG9yYWdlU3lzdGVtLmdldEl0ZW0oJ2ZpcnN0VmlzaXQnKSkge1xuICAgICAgICAgICAgdWkuZmFkZU91dCgnI2luaXRMb2FkZXInLCAzMDAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdWkucmVtb3ZlRWxlbWVudCgnI2luaXRMb2FkZXInKTtcbiAgICAgICAgICAgICAgICB1aS5tYWtlVmlzaWJsZSgnI21haW5XcmFwcGVyJywgNTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdWkuZmFkZU91dCgnI2luaXRMb2FkZXInLCA1NTAsICgpID0+IHtcbiAgICAgICAgICAgICAgICB1aS5yZW1vdmVFbGVtZW50KCcjaW5pdExvYWRlcicpO1xuICAgICAgICAgICAgICAgIHVpLm1ha2VWaXNpYmxlKCcjbWFpbldyYXBwZXInLCA1MDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0b3JhZ2VTeXN0ZW0uc2V0SXRlbSgnZmlyc3RWaXNpdCcsIHRydWUpO1xuXG4gICAgY3BPcGVuID0gc3RvcmFnZVN5c3RlbS5nZXRJdGVtKCdjcE9wZW4nKTtcbiAgICBjb25zb2xlLmxvZygnY3BPcGVuOjo6JywgY3BPcGVuKTtcbiAgICBpZihjcE9wZW4gPT0gJ2ZhbHNlJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNob3VsZCBzbGlkZTogY3BPcGVuXCIsIGNwT3Blbik7XG4gICAgICAgIHVpLnNsaWRlVG9nZ2xlQ3AoJ2NvbnRyb2xQYW5lbFdyYXBwZXInLCBNYXApO1xuICAgIH1cblxuICAgIHVpLmFkZEV2ZW50TGlzdGVuZXJUbygndG9nZ2xlU2xpZGVyQnRuJywgJ2NsaWNrJywgKGV2ZW50KSA9PiB1aS5zbGlkZVRvZ2dsZUNwKCdjb250cm9sUGFuZWxXcmFwcGVyJywgTWFwKSk7XG5cbiAgICBuZXcgTC5Db250cm9sLkdQbGFjZUF1dG9jb21wbGV0ZSh7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2NhdGlvbiBnaXZlbjonLCBsb2NhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBsYXQgPSBsb2NhdGlvbi5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxuZyA9IGxvY2F0aW9uLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuXG4gICAgICAgICAgICAvLyBjb25zdCBzYW5GcmFuY2lzY28gPSBbICctMTIyLjc1LCAzNi44LCAtMTIxLjc1LCAzNy44JyBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdExvY2F0aW9uID0gW2Ake2xuZ30sICR7bGF0fSwgJHtsbmcrMX0sICR7bGF0KzF9YF07XG5cbiAgICAgICAgICAgIHN0b3JhZ2VTeXN0ZW0uc2V0UmF3SXRlbSgnbGFzdExvY2F0aW9uJywgbGFzdExvY2F0aW9uKTtcbiAgICAgICAgICAgIE1hcC5zZXRWaWV3KFtsYXQsIGxuZ10sIDgsIHthbmltYXRlOiB0cnVlLCBkdXJhdGlvbjogMi4wfSk7XG4gICAgICAgIH1cbiAgICB9KS5hZGRUbyhNYXApO1xuXG4gICAgc29ja2V0Lm9uKCd0d2VldCcsICh0d2VldCkgPT4ge1xuICAgICAgICBsZXQgY29vcmRpbmF0ZXMgPSB0d2VldC5wbGFjZSA/IHR3ZWV0LnBsYWNlLmJvdW5kaW5nX2JveC5jb29yZGluYXRlc1swXVsxXSA6IG51bGw7XG4gICAgICAgIGlmKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IHR3ZWV0LnBsYWNlLmJvdW5kaW5nX2JveC5jb29yZGluYXRlc1swXVsxXTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0d2VldC51c2VyO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHR3ZWV0LnRleHQ7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHR3ZWV0LmlkO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZF9hdCA9IHR3ZWV0LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgICBjb25zdCBtbHNUaW1lID0gdHdlZXQudGltZXN0YW1wX21zO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG1sc1RpbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDEuIFByb2Nlc3Mgc2VudGltZW50IGJhc2VkIG9uIHBhc3NlZCB0ZXh0XG4gICAgICAgICAgICAvLyAyLiBEcmF3IGFuIG9iamVjdCB3aXRoIG1ldGFkYXRhIG9uIHRoZSBtYXBcbiAgICAgICAgICAgIC8vICAgIGFuZCBhbHNvIGRyYXcgaXQgb24gdGhlIHBhbmVsIChwYW5lbCBpcyBmb3IgZnV0dXJlIHdvcmspLlxuICAgICAgICAgICAgc2VudGltZW50LnByb2Nlc3NUZXh0KHt0ZXh0OiB0ZXh0fSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BST0NFU1NFRCBTRU5USU1FTlQgT0JKRUNUJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgR3JhcGhPcHMuZHJhd09iamVjdChkYXRhLCBjb29yZGluYXRlcywgJ3R3aXR0ZXInKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Bhc3NlZCB0d2VldCB3aXRoIG5vIGNvb3JkaW5hdGVzJywgdHdlZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZ1bmN0aW9uIGdldEluZm9CYXNlZE9uQ2hvc2VuTW9kZShtb2RlLCBxdWVyeSwgbGFzdExvY2F0aW9uLCB0d2l0RGF0YSkge1xuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICAgICAgY2FzZSAncmVhbF90aW1lJzpcbiAgICAgICAgICAgICAgICB0d2l0dGVyLnNvY2tldEVtaXQoc29ja2V0LCAndG9waWMnLCB7dG9waWM6IHF1ZXJ5LCBsb2NhdGlvbjogbGFzdExvY2F0aW9ufSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzcGVjaWZpZWRfdGltZSc6XG4gICAgICAgICAgICAgICAgdHdpdHRlci5nZXREYXRhKFBhdGhzLmdldFR3aXREYXRhKCksIHR3aXREYXRhKVxuICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gbmV3IEVycm9yKCdlcnInLCBlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vbmUgb2YgdGhlIG1vZGVzIHNlbGVjdGVkJyk7XG5cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdWkub25TdWJtaXQoJyNxdWVyeVNlYXJjaEZvcm0nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSB1aS5nZXRJbnB1dFZhbHVlKCcjcXVlcnlTZWFyY2gnKTtcbiAgICAgICAgY29uc3QgbGF0ID0gTWFwLmdldENlbnRlcigpLmxhdDtcbiAgICAgICAgY29uc3QgbG5nID0gTWFwLmdldENlbnRlcigpLmxuZztcbiAgICAgICAgY29uc3QgdHdpdERhdGEgPSB7cTogcXVlcnksIGdlb2NvZGU6IFtsYXQsIGxuZ10sIHJhZGl1czogJzI1bWknfTtcblxuICAgICAgICBsZXQgbGFzdExvY2F0aW9uID0gW2Ake2xuZ30sICR7bGF0fSwgJHtsbmcrMX0sICR7bGF0KzF9YF07XG5cbiAgICAgICAgaWYoUi5pc05pbChzdG9yYWdlU3lzdGVtLmdldEl0ZW0oJ2xhc3RMb2NhdGlvbicpKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdCBzZWxlY3RlZC4gdHdpdERhdGE6JywgdHdpdERhdGEpO1xuICAgICAgICAgICAgLy8gY29uc3QgdGVzdFR3aXREYXRhSXRlbVRlc3QgPSB7cTogJ3RydW1wJywgZ2VvY29kZTogWzM3Ljc3NDksIC0xMjIuNDE5NF0sIHJhZGl1czogJzI1bWknfTtcblxuICAgICAgICAgICAgZ2V0SW5mb0Jhc2VkT25DaG9zZW5Nb2RlKCdyZWFsX3RpbWUnLCBxdWVyeSwgbGFzdExvY2F0aW9uLCB0d2l0RGF0YSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFeGlzdHMnLCBsYXN0TG9jYXRpb24pO1xuXG4gICAgICAgICAgICAvKipcblxuICAgICAgICAgICAgICAgIFRPRE86XG4gICAgICAgICAgICAgICAgLSBUaGlzIGlzIGZvciBHZW5lcmFsIGFuZCBTZWxlY3RpdmUgdGltaW5nXG4gICAgICAgICAgICAgICAgLSBHZXQgZGF0YSBwb2ludHMgYW5kIGRyYXcgdGhlbSBvbiB0aGUgbWFwXG5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gY29uc3QgZmlyc3QgPSBHcmFwaE9wcy5nZW5lcmF0ZVJlc3VsdHMoWzEsIDIsIDMsIDRdKTtcbiAgICAgICAgICAgIC8vIGZpcnN0KGxhc3RMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIC8qKlxuXG4gICAgICAgICAgICAgICAgVE9ETzpcbiAgICAgICAgICAgICAgICAtIFRoaXMgcG9ydGlvbiBvZiBjb2RlIGlzIGZvciBTb2NrZXQuaW8vcmVhbCB0aW1lIHR3ZWV0IHN0cmVhbWluZ1xuICAgICAgICAgICAgICAgIC0gR2V0IGxvY2F0aW9uIGFuZCBxdWVyeSBhbmQgc3RhcnQgY29ubmVjdGluZyB0byB0aGUgc29ja2V0XG5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0SW5mb0Jhc2VkT25DaG9zZW5Nb2RlKCdzcGVjaWZpZWRfdGltZScsIHF1ZXJ5LCBsYXN0TG9jYXRpb24sIHR3aXREYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsYXN0IGxvY2F0aW9uIGlzIHNhdmVkXG4gICAgICAgIHN0b3JhZ2VTeXN0ZW0uc2V0UmF3SXRlbSgnbGFzdExvY2F0aW9uJywgbGFzdExvY2F0aW9uKTtcblxuICAgICAgICAvLyBvbmNlIHF1ZXJ5IHNlbGVjdGVkOlxuICAgICAgICAvLyBjaGVjayBpZiBsb2NhdGlvbiBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgIC8vIGlmIHllcywgdGhlbiBnbyB0byB0aGF0IGxvY2F0aW9uXG4gICAgICAgIC8vICAgICAgICAgIGFuZCBzaG93IHRoZSByZXN1bHRzXG4gICAgICAgIC8vIGlmIG5vLCB0aGVuIGdldCB0aGUgY2VudGVyIG9mIHRoZSBjdXJyZW50XG4gICAgICAgIC8vICAgICAgICBsb2NhdGlvbiBvZiB0aGUgc2NyZWVuIGFuZCBzaG93IHRoZSByZXN1bHRzLlxuICAgICAgICAvL1xuICAgIH0pO1xuXG4gICAgLy8gZ2VuZXJhdGlvblxuICAgIC8vIHVpLmdlbmVyYXRlQ3BSaWdodFBhbmVsKCcjcGFuZWxXcmFwcGVyJywge30pO1xuXG4gICAgLy8gVGVzdGluZyBhcmVhXG4gICAgbGV0IHRlc3RHZW8gPSAnLTI1LjI3NDQsLTEzMy43NzUxJzsgLy8gQXVzdHJhbGlhXG4gICAgLy8gY29uc29sZS5sb2coJ1BhdGg6JywgUGF0aHMuZ2V0R2VvVHJlbmRzKHRlc3RHZW8pKTtcbiAgICBjb25zb2xlLmxvZyhQYXRocy5nZXRHZW9UcmVuZHModGVzdEdlbykpO1xuICAgIFJlcXVlc3QuZ2V0UmVxdWVzdChQYXRocy5nZXRHZW9UcmVuZHModGVzdEdlbykpXG4gICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgaWYoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICBsZXQgbGlzdE9mVHJlbmRzID0gZGF0YS5kYXRhLnRyZW5kcztcbiAgICAgICAgICAgIGxldCBnZW9EYXRhID0gZGF0YS5nZW87XG5cbiAgICAgICAgICAgICQoXCIjcXVlcnlTZWFyY2hcIikuZWFzeUF1dG9jb21wbGV0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogbGlzdE9mVHJlbmRzLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgbGlzdDoge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblNob3dMaXN0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoKHN0b3JhZ2VTeXN0ZW0uZ2V0SXRlbSgnY3BPcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgJCgnLmVhc3ktYXV0b2NvbXBsZXRlLWNvbnRhaW5lcicpLmFkZENsYXNzKCdhdXRvY29tcGxldGUtdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgJCgnLmVhc3ktYXV0b2NvbXBsZXRlLWNvbnRhaW5lcicpLnJlbW92ZUNsYXNzKCdhdXRvY29tcGxldGUtdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAkKCcuZWFzeS1hdXRvY29tcGxldGUtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ2F1dG9jb21wbGV0ZS10b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goc3RvcmFnZVN5c3RlbS5nZXRJdGVtKCdjcE9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkuYWRkQ2xhc3MoJy5lYXN5LWF1dG9jb21wbGV0ZS1jb250YWluZXInLCAnYXV0b2NvbXBsZXRlLXRvcCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkucmVtb3ZlQ2xhc3MoJy5lYXN5LWF1dG9jb21wbGV0ZS1jb250YWluZXInLCAnYXV0b2NvbXBsZXRlLXRvcCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVDbGFzcygnLmVhc3ktYXV0b2NvbXBsZXRlLWNvbnRhaW5lcicsICdhdXRvY29tcGxldGUtdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25LZXlFbnRlckV2ZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRlbXBsYXRlOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHR5cGU6IFwiY3VzdG9tXCJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gbWV0aG9kOiBmdW5jdGlvbih2YWx1ZSwgaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyAgICAgcmV0dXJuIFwiPGltZyBzcmM9J1wiICsgaXRlbS5pY29uICsgXCInIC8+IHwgXCIgKyBpdGVtLnR5cGUgKyBcIiB8IFwiICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBkYXRhXCIsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyBmb3IobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgLy8gICAgIC8vICAgICB1aS5hZGRFbGVtZW50VG9QYW5lbFxuICAgICAgICAgICAgLy8gICAgIC8vICAgICAoXG4gICAgICAgICAgICAvLyAgICAgLy8gICAgICAgICAnI3BhbmVsQ29tcFJpZ2h0V3JhcHBlcicsXG4gICAgICAgICAgICAvLyAgICAgLy8gICAgICAgICB7fSxcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgICAgIFwiQnV0dG9uIFwiICsgaSxcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgICAgICQoJzxhPjwvYT4nKSxcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgICAgICdtZW51IGJ0biBidG4tc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgICAgICdjb2wtbGctNCdcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgKTtcbiAgICAgICAgICAgIC8vICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vICAgICAvLyB1bmRlZmluZWQgYnkgZGVmYXVsdCB3aWxsIHBsYWNlICdkaXYnIGVsZW1lbnRcblxuICAgICAgICAgICAgLy8gICAgIC8vIHVpLmFkZEVsZW1lbnRUbygnJylcblxuICAgICAgICAgICAgLy8gfSgpKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1Nob3VsZCByZWFjaCBoZXJlLi4uJyk7XG4gICAgICAgICAgICAvLyBsZXQgZHJvcGRvd24gPSB1aS5hZGRDb250YWluZXJUb0NvbnRhaW5lcignI3BhbmVsQ29tcFJpZ2h0V3JhcHBlcicsICdmYXZvcml0ZXMnLCB1bmRlZmluZWQsICdkcm9wZG93biBzaG93Jyk7XG4gICAgICAgICAgICAvLyBsZXQgJGEgPSB1aS5hZGRDb250YWluZXJUb0NvbnRhaW5lcihkcm9wZG93bi5hdHRyKCdpZCcpLCB1bmRlZmluZWQsICQoJzxhPicpLCAnYnRuIGJ0bi1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlJyk7XG4gICAgICAgICAgICAvLyB1aS5hZGRUZXh0VG8oJGEsICRhLmF0dHIoJ2lkJykpO1xuXG4gICAgICAgICAgICAvL3RhcmdldCwgZHJvcGRvd25OYW1lLCBkcm9wZG93bklELCBkYXRhTGlzdFxuXG5cbiAgICAgICAgICAgIGxldCBwYW5lbENvbXAxID0gbmV3IFBhbmVsQ29tcG9uZW50KCcjdG9wVGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RvcCAxMCBUd2VldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpe2NvbnNvbGUubG9nKCdoaScpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3tcIm5hbWVcIjpcImRhbGVyXCJ9LCB7XCJuYW1lXCI6XCJtaWNoYWVsXCJ9XSk7XG4gICAgICAgICAgICBsZXQgcGFuZWxDb21wMiA9IG5ldyBQYW5lbENvbXBvbmVudCgnI3RvcFR3ZW50eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVG9wIDEwIFJldHdlZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coJ2hpJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3tcImxhc3RuYW1lXCI6XCJhc3Jvcm92XCJ9LCB7XCJsYXN0bmFtZVwiOlwiam9qb1wifV0pO1xuICAgICAgICAgICAgbGV0IHBhbmVsQ29tcDMgPSBuZXcgUGFuZWxDb21wb25lbnQoJyN0b3BUaGlydHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RvcCAzMCBSZXR3ZWV0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpeyBjb25zb2xlLmxvZygnaGknKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3tcImpvcmdlXCI6XCJxdWVyb1wifSwge1wic2FuZHJvXCI6XCJib2xvXCJ9XSk7XG5cbiAgICAgICAgICAgIHJpZ2h0Q29tcG9uZW50cy5hZGQocGFuZWxDb21wMSk7XG4gICAgICAgICAgICByaWdodENvbXBvbmVudHMuYWRkKHBhbmVsQ29tcDIpO1xuICAgICAgICAgICAgcmlnaHRDb21wb25lbnRzLmFkZChwYW5lbENvbXAzKTtcbiAgICAgICAgICAgIHJpZ2h0Q29tcG9uZW50cy5zZXROYW1lKCdTb2NpYWwgTWVkaWEnKTtcbiAgICAgICAgICAgIHJpZ2h0Q29tcG9uZW50cy5zZXRJZCgnc29jTWVkaWEnKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYW5lbENvbXAgb2JqZWN0OlwiLCByaWdodENvbXBvbmVudHMpO1xuICAgICAgICAgICAgdWkuYXBwZW5kRHJvcERvd25Ub1BhbmVsKCcjcGFuZWxDb21wUmlnaHRXcmFwcGVyJywgcmlnaHRDb21wb25lbnRzKTtcblxuICAgIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciByZXF1ZXN0XCIsIGVycik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcnJheU9mSW5kZXhlcyA9IFRXSVRURVJfTU9ERVMubWFwKChpdGVtLCBpbmRleCkgPT4gaW5kZXgpO1xuICAgIGNvbnN0IGFycmF5T2ZMYWJlbHMgPSBUV0lUVEVSX01PREVTLm1hcCgobW9kZSkgPT4gdXRpbHMudGl0bGVDYXNlKG1vZGUuc3BsaXQoJ18nKS5qb2luKCcgJykpKTtcbiAgICB1aS5hcHBlbmRSYW5nZVNsaWRlcignI3BhbmVsQ29tcE1pZGRsZScsICdyYW5nZS1zZWxlY3RvcicsICd0d2l0dGVyTW9kZXMnLCB7XG4gICAgICAgIHRpY2tzOiBhcnJheU9mSW5kZXhlcyxcbiAgICAgICAgdGlja3NMYWJlbHM6IGFycmF5T2ZMYWJlbHMsXG4gICAgICAgIG1pbjogYXJyYXlPZkluZGV4ZXNbMF0sXG4gICAgICAgIG1heDogYXJyYXlPZkluZGV4ZXNbYXJyYXlPZkluZGV4ZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIHZhbHVlOiBhcnJheU9mSW5kZXhlc1swXSxcbiAgICAgICAgdG9vbHRpcDogJ2hpZGUnLFxuICAgICAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uKHNsaWRlRXZ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TW9kZSA9IHNsaWRlRXZ0LnZhbHVlLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNb2RlID0gc2xpZGVFdnQudmFsdWUub2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgc3dpdGNoKG5ld01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUV0lUVEVSX01PREVTX0lOREVYWydyZWFsX3RpbWUnXTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRXSVRURVJfTU9ERVNfSU5ERVhbJ3NwZWNpZmllZF90aW1lJ106XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uIGRhdGEgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgcmV0dXJuIGxvY2F0aW9uIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgc3RvcmUgbG9jYXRpb24gaW4gY2FjaGUgaW4gKGtleSwgdmFsdWUpIHBhaXIgd2hlcmUga2V5IGlzIGxvY2F0aW9uIGFuZCB2YWx1ZSBpcyB0d2VldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgcmV0dXJuIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHVpLmdldElucHV0VmFsdWUoJyNxdWVyeVNlYXJjaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ID0gTWFwLmdldENlbnRlcigpLmxhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxuZyA9IE1hcC5nZXRDZW50ZXIoKS5sbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0d2l0RGF0YSA9IHtxOiBxdWVyeSwgZ2VvY29kZTogW2xhdCwgbG5nXSwgcmFkaXVzOiAnMjVtaSd9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdpdHRlci5nZXREYXRhKFBhdGhzLmdldFR3aXREYXRhKCksIHR3aXREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vbmUgc2VsZWN0ZWQnKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXZlbnQ6IGNoYW5nZS4gU2xpZGVyIG9iamVjdCcsIHNsaWRlRXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBSZXF1ZXN0LmdldFJlcXVlc3QoVXRpbHMuZ2V0VHJlbmRzUGxhY2VzKGxhdCwgbG9uZykpw6VcbiAgICAvLyAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwiVHJlbmRzIERhdGFcIik7XG4gICAgLy8gICAgIH0pXG5cbiAgICAvLyBwb3N0IHJlcXVlc3QgdGVzdGluZ1xuXG5cbn0pO1xuIl0sIm5hbWVzIjpbIm1hcExheWVyIiwiTVEiLCJtYWluTWFwIiwiTCIsIm1hcCIsImNvbnRyb2wiLCJsYXllcnMiLCJoeWJyaWRMYXllciIsInNhdGVsbGl0ZUxheWVyIiwiZGFya0xheWVyIiwibGlnaHRMYXllciIsImFkZFRvIiwiU3RvcmFnZSIsImtleSIsInZhbHVlIiwiU3RvcmFnZVN5c3RlbSIsImxvY2FsU3RvcmFnZSIsIl9sb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInNsaWRlVG9nZ2xlQ3AiLCJ0YXJnZXRJRCIsImhlaWdodFNldHRlcklEIiwiY3BEZWZhdWx0SGVpZ2h0IiwiY3BOYXZIZWlnaHQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib2Zmc2V0SGVpZ2h0IiwidG9TdHJpbmciLCJjcFdyYXBwZXJIZWlnaHQiLCJzbGlkaW5nVGltZSIsImRlZmF1bHRUb3AiLCIkcXVlcnlTZWFyY2hGb3JtIiwiJCIsIiR0YXJnZXQiLCIkYm9keSIsIiRzbGlkZVN3aXRjaEljb24iLCJzdG9yYWdlU3lzdGVtIiwid2luZG93IiwiY3NzIiwiYW5pbWF0ZSIsImhlaWdodCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJpbnZhbGlkYXRlU2l6ZSIsInRhcmdldCIsImNsYXNzTmFtZSIsImFkZEV2ZW50TGlzdGVuZXJUbyIsInR5cGUiLCJmbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFbGVtZW50IiwicmVtb3ZlIiwiZmFkZU91dCIsInRpbWVyIiwiY2FsbGJhY2siLCJtYWtlVmlzaWJsZSIsIm9wYWNpdHkiLCJ2aXNpYmlsaXR5IiwiYXBwZW5kRHJvcERvd25UbyIsImRyb3Bkb3duTmFtZSIsImRyb3Bkb3duSUQiLCJhY3Rpb25zTGlzdCIsIiR0YXJnZXRSZWYiLCJhcHBlbmQiLCIkZHJvcGRvd24iLCJmaW5kIiwiJGRyb3Bkb3duUmVmIiwiJGxpc3REaXYiLCJhY3Rpb24iLCJpbmRleCIsImlkIiwibmFtZSIsImFwcGVuZFJhbmdlU2xpZGVyIiwiY29udGFpbmVyIiwiZGl2Q2xhc3MiLCJpbnB1dElkIiwicGFyYW1zIiwibmV3UmFuZ2VTbGlkZXIiLCJyYW5nZUlucHV0Iiwic2xpZGVyIiwidGlja3MiLCJ0aWNrc0xhYmVscyIsIm1pbiIsIm1heCIsInN0ZXAiLCJ0b29sdGlwIiwiT2JqZWN0IiwiZW50cmllcyIsImV2ZW50SGFuZGxlcnMiLCJvbiIsImxvZyIsImFwcGVuZFRvIiwiZWxlbWVudCIsImFwcGVuZERyb3BEb3duVG9QYW5lbCIsImNvbXBvbmVudHNDbGFzcyIsImxpc3QiLCJvblN1Ym1pdCIsInN1Ym1pdCIsImdldElucHV0VmFsdWUiLCJ2YWwiLCJnZXRSZXF1ZXN0IiwidXJsIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImdldCIsImRhdGEiLCJzdGF0dXMiLCJwb3N0UmVxdWVzdCIsImluZm8iLCJwb3N0IiwiZ2V0R2VvVHJlbmRzIiwibGF0TG9uZ1N0cmluZyIsImxvY2F0aW9uIiwib3JpZ2luIiwiZ2V0VHdpdERhdGEiLCJnZXRTZW50aW1lbnRUZXh0QW5hbHlzaXMiLCJ0aXRsZUNhc2UiLCJzdHIiLCJlc2NhcGVSZWciLCJzIiwicmVwbGFjZSIsImMiLCJ3b3JkUGF0dGVybiIsIlJlZ0V4cCIsInJlc3VsdCIsImNhcGl0YWxpemUiLCJsZW5ndGgiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJNQUlOIiwiSU1BR0VTIiwiY3JlYXRlSWNvbiIsImljb25VcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsInNoYWRvd1NpemUiLCJpY29uQW5jaG9yIiwic2hhZG93SWNvbiIsInBvcHVwQW5jaG9yIiwidHdpdHRlckljb24iLCJpY29uIiwiZ2VuZXJhdGVSZXN1bHRzIiwiX2RlZmF1bHQiLCJnZW8iLCJfZGVmYXVsdDMiLCJkcmF3TWFya2VyIiwicG9pbnREYXRhIiwiTWFwRWxlbWVudHMiLCJTT0NfTUVESUFfSUNPTlMiLCJUV0lUVEVSIiwibWFya2VyIiwiTWFwIiwiZHJhd09iamVjdCIsImdlb2xvY2F0aW9uIiwiaWNvblR5cGUiLCJQYW5lbENvbXBvbmVudCIsImFjdGlvbkhhbmRsZXIiLCJhc2NlbmRpbmciLCJzb3J0ZWREYXRhIiwiZGVzY0NvbXBhcmF0b3IiLCJSIiwiY29tcGFyYXRvciIsImEiLCJiIiwiZ3QiLCJwcm9wIiwic29ydEJ5Iiwic29ydCIsImxpbWl0IiwiZm9ybWF0dGVkIiwiZ2V0U29ydGVkRGF0YUJ5IiwiQ29tcG9uZW50cyIsInBhbmVsQ29tcG9uZW50IiwicHVzaCIsImkiLCJzcGxpY2UiLCJNb2RlIiwiVHdpdHRlciIsInNvY2tldCIsImNoYW5uZWwiLCJlbWl0IiwidHdpdERhdGEiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJTZW50aW1lbnQiLCJzZW50aW1lbnRJbnB1dCIsInJlcSIsIl9pZCIsImxvYWQiLCJ0d2l0dGVyIiwiVFdJVFRFUl9NT0RFUyIsImNvbnN0YW50cyIsIlRXSVRURVJfTU9ERVNfSU5ERVgiLCJzZW50aW1lbnQiLCJpbyIsImNvbm5lY3QiLCJjcE9wZW4iLCJ0cmFja2VyIiwiY3BSaWdodExpc3QiLCJyaWdodENvbXBvbmVudHMiLCJldmVudCIsInVpIiwiQ29udHJvbCIsIkdQbGFjZUF1dG9jb21wbGV0ZSIsImxhdCIsImdlb21ldHJ5IiwibG5nIiwibGFzdExvY2F0aW9uIiwic2V0UmF3SXRlbSIsInNldFZpZXciLCJkdXJhdGlvbiIsInR3ZWV0IiwiY29vcmRpbmF0ZXMiLCJwbGFjZSIsImJvdW5kaW5nX2JveCIsInVzZXIiLCJ0ZXh0IiwiY3JlYXRlZF9hdCIsIm1sc1RpbWUiLCJ0aW1lc3RhbXBfbXMiLCJwcm9jZXNzVGV4dCIsImdldEluZm9CYXNlZE9uQ2hvc2VuTW9kZSIsIm1vZGUiLCJxdWVyeSIsInNvY2tldEVtaXQiLCJ0b3BpYyIsImdldERhdGEiLCJQYXRocyIsImNvbnNvbGUiLCJFcnJvciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImdldENlbnRlciIsInEiLCJnZW9jb2RlIiwicmFkaXVzIiwidGVzdEdlbyIsImxpc3RPZlRyZW5kcyIsInRyZW5kcyIsImdlb0RhdGEiLCJlYXN5QXV0b2NvbXBsZXRlIiwicGFuZWxDb21wMSIsInBhbmVsQ29tcDIiLCJwYW5lbENvbXAzIiwiYWRkIiwic2V0TmFtZSIsInNldElkIiwiYXJyYXlPZkluZGV4ZXMiLCJpdGVtIiwiYXJyYXlPZkxhYmVscyIsInV0aWxzIiwic3BsaXQiLCJqb2luIiwic2xpZGVFdnQiLCJuZXdNb2RlIiwibmV3VmFsdWUiLCJwcmV2TW9kZSIsIm9sZFZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7QUFBQSxrQkFBYyxHQUFHLFNBQVMsY0FBYyxDQUFDLENBQUMsRUFBRTtFQUMxQyxPQUFPLENBQUMsSUFBSSxJQUFJO1NBQ1QsT0FBTyxDQUFDLEtBQUssUUFBUTtTQUNyQixDQUFDLENBQUMsMEJBQTBCLENBQUMsS0FBSyxJQUFJLENBQUM7Q0FDL0MsQ0FBQzs7QUNERjs7Ozs7Ozs7QUFRQSxXQUFjLEdBQUcsU0FBUyxPQUFPLENBQUMsRUFBRSxFQUFFO0VBQ3BDLE9BQU8sU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ3BCLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFO01BQy9DLE9BQU8sRUFBRSxDQUFDO0tBQ1gsTUFBTTtNQUNMLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDbEM7R0FDRixDQUFDO0NBQ0gsQ0FBQzs7QUNoQkY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLFNBQWMsR0FBRyxPQUFPLENBQUMsU0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztBQ25CbEU7Ozs7Ozs7O0FBUUEsSUFBSUEsV0FBV0MsR0FBR0QsUUFBSCxFQUFmO0lBQThCRSxnQkFBOUI7O0FBRUFBLFVBQVVDLEVBQUVDLEdBQUYsQ0FBTSxZQUFOLEVBQW9CO1VBQ2xCSixRQURrQjtVQUVsQixDQUFFLFNBQUYsRUFBYSxDQUFDLFNBQWQsQ0FGa0I7UUFHcEI7Q0FIQSxDQUFW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QyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDdEUsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDMUUsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzlFLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbEYsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDdEYsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzFGLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVB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LENBQUMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRTtlQUNoRSxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztlQUM1RixjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztlQUM1RixjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztlQUM1RixjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7ZUFDbEUsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2VBQ2xFLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztlQUNsRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENB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
